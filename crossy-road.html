<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crossy Road - Simple Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #d946ef 100%);
            font-family: 'Poppins', sans-serif;
            padding: 20px;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1),
                        0 0 0 1px rgba(255, 255, 255, 0.2) inset;
            border: 1px solid rgba(255, 255, 255, 0.18);
            max-width: 650px;
            width: 100%;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 3em;
            font-weight: 800;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            letter-spacing: -1px;
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 12px;
            flex-wrap: wrap;
        }

        .score-item {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 16px;
            color: white;
            font-size: 1em;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .score-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
                        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            background: #87CEEB;
            position: relative;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            transition: transform 0.3s ease;
        }

        canvas:active {
            transform: scale(0.99);
        }

        .score-display {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            color: white;
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 1.5em;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 100;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .coin-display {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(255, 193, 7, 0.3);
            backdrop-filter: blur(8px);
            color: white;
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 1.5em;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 100;
            pointer-events: none;
            border: 1px solid rgba(255, 215, 0, 0.4);
        }

        .flight-display {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: white;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 2em;
            font-weight: 700;
            z-index: 101;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(251, 191, 36, 0.6),
                        0 0 0 1px rgba(255, 255, 255, 0.3) inset;
            border: 2px solid rgba(255, 255, 255, 0.4);
            animation: pulse 0.5s infinite alternate;
        }

        .flight-display.active {
            display: block;
        }

        .power-display {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            padding: 12px 24px;
            border-radius: 16px;
            font-size: 1.1em;
            font-weight: 600;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2),
                        0 0 0 1px rgba(255, 255, 255, 0.2) inset;
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
        }

        .power-display.active {
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            animation: powerPulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            from {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 8px 32px rgba(251, 191, 36, 0.6);
            }
            to {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 12px 48px rgba(251, 191, 36, 0.8);
            }
        }

        @keyframes powerPulse {
            from {
                transform: translateX(-50%) scale(1);
                box-shadow: 0 4px 16px rgba(139, 92, 246, 0.6);
            }
            to {
                transform: translateX(-50%) scale(1.05);
                box-shadow: 0 6px 24px rgba(236, 72, 153, 0.8);
            }
        }

        .settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 56px;
            height: 56px;
            font-size: 1.6em;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .settings-btn:active {
            transform: rotate(90deg) scale(1.05);
        }

        .settings-btn.hidden {
            display: none;
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10003;
            overflow-y: auto;
        }

        .settings-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .settings-content h2 {
            color: white;
            margin-bottom: 20px;
            text-align: center;
            font-size: 2em;
        }

        .settings-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .settings-section h3 {
            color: white;
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .setting-item {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .setting-item label {
            color: white;
            font-size: 1em;
            flex: 1;
        }

        .setting-item input[type="number"],
        .setting-item input[type="range"] {
            width: 100px;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.9);
            margin-left: 10px;
        }

        .setting-item .range-value {
            color: white;
            min-width: 50px;
            text-align: right;
            font-weight: bold;
        }

        .settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .settings-buttons button {
            flex: 1;
            padding: 14px 24px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn-save {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-save:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .btn-cancel {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-cancel:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }

        .btn-reset {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #d97706, #b45309);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
        }

        .settings-buttons button:active {
            transform: translateY(0);
        }

        .controls {
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9em;
            font-weight: 500;
            line-height: 1.6;
        }

        .controls p {
            margin: 4px 0;
        }

        .character-selector {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.18);
            z-index: 50;
        }

        .character-selector h3 {
            color: white;
            font-size: 1.1em;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
        }

        .character-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .character-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .character-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-4px);
        }

        .character-option.active {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 16px rgba(255, 255, 255, 0.2);
        }

        .character-preview {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character-option span {
            color: white;
            font-size: 0.9em;
            font-weight: 600;
        }

        @media (max-width: 900px) {
            .character-selector {
                position: static;
                transform: none;
                margin: 20px auto;
                max-width: 500px;
            }

            .character-list {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .character-option {
                flex: 1;
                min-width: 80px;
            }
        }

        /* Fullscreen Shop Styles */
        .fullscreen-shop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            z-index: 10000;
            display: none;
            overflow-y: auto;
            padding: 40px 20px;
        }

        .shop-header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .shop-header h2, .shop-coin-display, .close-shop-btn {
            pointer-events: auto; /* Re-enable for interactive elements */
        }

        .shop-header h2 {
            color: white;
            font-size: 3.5em;
            font-weight: 800;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .shop-coin-display {
            color: white;
            font-size: 1.8em;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .close-shop-btn {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(220, 38, 38, 0.9);
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 20px 40px;
            font-size: 1.5em;
            font-weight: 800;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10002;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            pointer-events: auto; /* Ensure button is always clickable */
        }

        .close-shop-btn:hover {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.1);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.6);
        }

        .close-shop-btn:active {
            transform: scale(0.95);
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .shop-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 24px;
            padding: 40px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .shop-card:hover:not(.purchased) {
            transform: translateY(-10px);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.25);
        }

        .shop-card.purchased {
            opacity: 0.6;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.2);
        }

        .shop-card-icon {
            font-size: 5em;
            margin-bottom: 20px;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.2));
        }

        .shop-card h3 {
            color: white;
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .shop-card-desc {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .shop-card-price {
            color: #ffd700;
            font-size: 1.8em;
            font-weight: 800;
            margin-bottom: 15px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .shop-card-status {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1em;
            font-weight: 600;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: inline-block;
        }

        /* Shop Airstrike Code Panel */
        .shop-airstrike-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .shop-airstrike-content {
            background: linear-gradient(135deg, #dc2626, #991b1b);
            padding: 50px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 12px 48px rgba(220, 38, 38, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.4);
            max-width: 500px;
        }

        .shop-airstrike-content h3 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .shop-airstrike-content p {
            color: white;
        }

        .shop-code-display {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 3em;
            font-weight: 800;
            color: white;
            letter-spacing: 12px;
            margin: 20px 0;
            border: 3px solid rgba(255, 255, 255, 0.4);
        }

        .shop-code-input {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 2.5em;
            font-weight: 800;
            color: #4ade80;
            letter-spacing: 10px;
            min-height: 60px;
            border: 3px solid rgba(74, 222, 128, 0.5);
            margin: 20px 0;
        }

        .btn-back-shop {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 15px 35px;
            font-size: 1.2em;
            font-weight: 700;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .btn-back-shop:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        /* Airstrike Code Panel (Always Visible) */
        .airstrike-code-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(255, 0, 0, 0.4);
            border: 2px solid rgba(255, 0, 0, 0.6);
            z-index: 150;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .airstrike-code-label {
            color: #ff4444;
            font-size: 0.9em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .airstrike-code-value {
            background: rgba(255, 255, 255, 0.15);
            padding: 10px 25px;
            border-radius: 10px;
            font-size: 2em;
            font-weight: 800;
            color: white;
            letter-spacing: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .airstrike-input-feedback {
            font-size: 1.5em;
            font-weight: 700;
            color: #4ade80;
            letter-spacing: 8px;
            min-height: 30px;
            text-shadow: 0 2px 8px rgba(74, 222, 128, 0.5);
        }

        .airstrike-message {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #dc2626, #991b1b);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 2.5em;
            font-weight: 800;
            z-index: 200;
            pointer-events: none;
            box-shadow: 0 12px 48px rgba(220, 38, 38, 0.8),
                        0 0 0 2px rgba(255, 255, 255, 0.3) inset;
            border: 3px solid rgba(255, 255, 255, 0.4);
            animation: airstrikeAlert 0.5s infinite alternate;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        @keyframes airstrikeAlert {
            from {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 12px 48px rgba(220, 38, 38, 0.8);
            }
            to {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 16px 64px rgba(220, 38, 38, 1);
            }
        }

        @media (max-width: 900px) {
            .shop-container {
                position: static;
                transform: none;
                margin: 20px auto;
                max-width: 500px;
            }
        }

        .game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: white;
            padding: 50px;
            border-radius: 24px;
            text-align: center;
            z-index: 10002;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            min-width: 320px;
        }

        .game-over h2 {
            font-size: 3.5em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
        }

        .game-over p {
            font-size: 1.2em;
            margin: 10px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        .game-over button {
            margin-top: 30px;
            padding: 16px 48px;
            font-size: 1.2em;
            font-weight: 600;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4);
        }

        .game-over button:hover {
            background: linear-gradient(135deg, #8b5cf6, #d946ef);
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(139, 92, 246, 0.6);
        }

        .game-over button:active {
            transform: translateY(0);
        }

        .fullscreen-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 10px 18px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }

        .fullscreen-btn:hover {
            background: rgba(0, 0, 0, 0.7);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .fullscreen-btn:active {
            transform: translateY(0);
        }

        #fullscreenContainer .fullscreen-btn {
            position: fixed;
            top: 16px;
            right: 16px;
        }

        .exit-fullscreen-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10001;
        }

        .exit-fullscreen-btn:hover {
            background: rgba(255, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .exit-fullscreen-btn.show {
            display: block;
        }

        #fullscreenContainer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        #fullscreenContainer.active {
            display: flex;
        }

        #fullscreenContainer canvas {
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            object-fit: contain;
        }

        #fullscreenContainer .score-display {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 2.5em;
        }

        #fullscreenContainer .coin-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 2.5em;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>🐔 Crossy Road</h1>
        <button class="settings-btn" id="settingsBtn" onclick="openSettings()">⚙️</button>
        <div class="score-board">
            <div class="score-item">
                <div>High Score: <span id="highScore">0</span></div>
            </div>
        </div>
        <div style="position: relative; display: inline-block;" id="canvasContainer">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div class="score-display"><span id="scoreDisplay">0</span></div>
            <div class="coin-display">🪙 <span id="coinDisplay">0</span></div>
            <div class="flight-display" id="flightDisplay">✈️ FLYING: <span id="flightTime">5.0</span>s</div>
            <div class="power-display" id="powerDisplay"></div>
            <button class="fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
        </div>
        <div class="controls">
            <p>🎮 Desktop: Arrow Keys to move | SPACE for character power</p>
            <p>↑ Up | ↓ Down | ← Left | → Right | ␣ Special Ability</p>
            <p>Mobile: Tap forward, Swipe to change direction</p>
        </div>
    </div>

    <!-- Character Selection -->
    <div class="character-selector">
        <h3>Choose Character</h3>
        <div class="character-list">
            <div class="character-option active" data-character="chick" onclick="selectCharacter('chick')">
                <canvas class="character-preview" id="preview-chick" width="60" height="60"></canvas>
                <span>🐥 Chick</span>
            </div>
            <div class="character-option" data-character="goose" onclick="selectCharacter('goose')">
                <canvas class="character-preview" id="preview-goose" width="60" height="60"></canvas>
                <span>🦆 Goose</span>
            </div>
            <div class="character-option" data-character="ghost" onclick="selectCharacter('ghost')">
                <canvas class="character-preview" id="preview-ghost" width="60" height="60"></canvas>
                <span>👻 Ghost</span>
            </div>
            <div class="character-option" data-character="military" onclick="selectCharacter('military')">
                <canvas class="character-preview" id="preview-military" width="60" height="60"></canvas>
                <span>🪖 Soldier</span>
            </div>
            <div class="character-option" data-character="dog" onclick="selectCharacter('dog')">
                <canvas class="character-preview" id="preview-dog" width="60" height="60"></canvas>
                <span>🐕 Emma</span>
            </div>
        </div>
    </div>

    <!-- Fullscreen Power-Up Shop -->
    <div class="fullscreen-shop" id="fullscreenShop" style="display: none;">
        <div class="shop-header">
            <h2>⚡ POWER-UP SHOP ⚡</h2>
            <div class="shop-coin-display">💰 Coins: <span id="shopCoins">0</span></div>
            <button class="close-shop-btn" id="closeShopBtn">✖ EXIT (ESC)</button>
        </div>
        <div class="shop-grid">
            <div class="shop-card" data-powerup="speed" onclick="buyPowerUp('speed')">
                <div class="shop-card-icon">🚀</div>
                <h3>Speed Boost</h3>
                <p class="shop-card-desc">Increases your movement speed by 0.9%</p>
                <div class="shop-card-price">💰 1 Coin</div>
                <div class="shop-card-status">Click to Purchase</div>
            </div>
            <div class="shop-card" data-powerup="freeze" onclick="buyPowerUp('freeze')">
                <div class="shop-card-icon">❄️</div>
                <h3>Freeze Time</h3>
                <p class="shop-card-desc">Stop all cars for 4 seconds</p>
                <div class="shop-card-price">💰 1 Coin</div>
                <div class="shop-card-status">Click to Purchase</div>
            </div>
            <div class="shop-card" data-powerup="lives" onclick="buyPowerUp('lives')">
                <div class="shop-card-icon">❤️</div>
                <h3>Extra Lives</h3>
                <p class="shop-card-desc">Get 2 additional lives</p>
                <div class="shop-card-price">💰 2 Coins</div>
                <div class="shop-card-status">Click to Purchase</div>
            </div>
            <div class="shop-card" data-powerup="airstrike" onclick="buyPowerUp('airstrike')">
                <div class="shop-card-icon">💣</div>
                <h3>Airstrike</h3>
                <p class="shop-card-desc">Clear all cars for 9.5 seconds & eliminate wolf for 10 seconds. Code: 6741</p>
                <div class="shop-card-price">💰 4 Coins</div>
                <div class="shop-card-status">Click to Purchase</div>
            </div>
            <div class="shop-card" data-powerup="rainbow" onclick="buyPowerUp('rainbow')">
                <div class="shop-card-icon">🌈</div>
                <h3>Rainbow Road</h3>
                <p class="shop-card-desc">Spawns a safe grass lane for 20 spaces. No cars can touch it. Press R to activate.</p>
                <div class="shop-card-price">💰 4 Coins</div>
                <div class="shop-card-status">Click to Purchase</div>
            </div>
            <div class="shop-card" data-powerup="tsunami" onclick="buyPowerUp('tsunami')">
                <div class="shop-card-icon">🌊</div>
                <h3>Tsunami</h3>
                <p class="shop-card-desc">Sweeps all cars off one side of the screen with a wave of water. 6-second duration.</p>
                <div class="shop-card-price">💰 5 Coins</div>
                <div class="shop-card-status">Click to Purchase</div>
            </div>
        </div>
    </div>

    <!-- Airstrike Code Display (Always Visible When Owned) -->
    <div class="airstrike-code-panel" id="airstrikeCodePanel" style="display: none;">
        <div class="airstrike-code-label">🎯 AIRSTRIKE CODE:</div>
        <div class="airstrike-code-value">6741</div>
        <div class="airstrike-input-feedback" id="airstrikeInputFeedback"></div>
    </div>

    <!-- Airstrike Incoming Message -->
    <div class="airstrike-message" id="airstrikeMessage" style="display: none;">
        ⚠️ AIRSTRIKE INCOMING ⚠️
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER!</h2>
        <p style="font-size: 1.5em;">Final Score: <span id="finalScore">0</span></p>
        <p style="font-size: 1.2em; margin-top: 10px;">High Score: <span id="finalHighScore">0</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <div id="fullscreenContainer"></div>

    <button class="exit-fullscreen-btn" id="exitFullscreenBtn" onclick="exitFullscreen()">✕ Exit Fullscreen</button>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <h2>⚙️ Game Settings</h2>

            <div class="settings-section">
                <h3>🚗 Vehicle Settings</h3>
                <div class="setting-item">
                    <label>Vehicle Density (Min):</label>
                    <input type="number" id="vehicleDensityMin" min="1" max="5" value="1">
                </div>
                <div class="setting-item">
                    <label>Vehicle Density (Max):</label>
                    <input type="number" id="vehicleDensityMax" min="1" max="5" value="2">
                </div>
                <div class="setting-item">
                    <label>Vehicle Speed (Min):</label>
                    <input type="number" id="vehicleSpeedMin" min="0.01" max="0.1" step="0.01" value="0.02">
                </div>
                <div class="setting-item">
                    <label>Vehicle Speed (Max):</label>
                    <input type="number" id="vehicleSpeedMax" min="0.01" max="0.1" step="0.01" value="0.05">
                </div>
                <div class="setting-item">
                    <label>Road Frequency (Every X rows):</label>
                    <input type="number" id="vehicleSpawnFrequency" min="2" max="10" value="3">
                </div>
                <div class="setting-item">
                    <label>Min Road Lanes:</label>
                    <input type="number" id="minLanes" min="1" max="5" value="1">
                </div>
                <div class="setting-item">
                    <label>Max Road Lanes:</label>
                    <input type="number" id="maxLanes" min="1" max="5" value="5">
                </div>
            </div>

            <div class="settings-section">
                <h3>✈️ Flight Power-Up</h3>
                <div class="setting-item">
                    <label>Coins Required for Flight:</label>
                    <input type="number" id="coinsForFlight" min="1" max="20" value="5">
                </div>
                <div class="setting-item">
                    <label>Flight Duration (seconds):</label>
                    <input type="number" id="flightDuration" min="1" max="20" step="0.5" value="5">
                </div>
                <div class="setting-item">
                    <label>Flight Movement Delay (ms):</label>
                    <input type="number" id="flightMovementDelay" min="50" max="500" step="50" value="150">
                </div>
            </div>

            <div class="settings-section">
                <h3>🪙 Coin Settings</h3>
                <div class="setting-item">
                    <label>Coin Spawn Min (jumps):</label>
                    <input type="number" id="coinSpawnMin" min="1" max="20" value="5">
                </div>
                <div class="setting-item">
                    <label>Coin Spawn Max (jumps):</label>
                    <input type="number" id="coinSpawnMax" min="5" max="30" value="18">
                </div>
                <div class="setting-item">
                    <label>Coin Distance Min (rows ahead):</label>
                    <input type="number" id="coinSpawnDistanceMin" min="2" max="20" value="8">
                </div>
                <div class="setting-item">
                    <label>Coin Distance Max (rows ahead):</label>
                    <input type="number" id="coinSpawnDistanceMax" min="5" max="30" value="12">
                </div>
            </div>

            <div class="settings-section">
                <h3>🐺 Wolf Chase</h3>
                <div class="setting-item">
                    <label>Wolf Wait Time (seconds):</label>
                    <input type="number" id="wolfChaseDelay" min="1" max="10" step="0.5" value="3">
                </div>
                <div class="setting-item">
                    <label>Wolf Speed (jumps/second):</label>
                    <input type="number" id="wolfSpeed" min="0.5" max="5" step="0.1" value="2">
                </div>
                <div class="setting-item">
                    <label>Wolf Spawn Distance (rows behind):</label>
                    <input type="number" id="wolfSpawnDistance" min="3" max="15" step="1" value="5">
                </div>
            </div>

            <div class="settings-section">
                <h3>🎮 Game Difficulty</h3>
                <div class="setting-item">
                    <label>Win Score:</label>
                    <input type="number" id="winScore" min="50" max="1000" step="50" value="333">
                </div>
            </div>

            <div class="settings-section">
                <h3>🏪 Shop Settings</h3>
                <div class="setting-item">
                    <label>Shop Unlock Score (Jumps/Steps):</label>
                    <input type="number" id="shopUnlockScore" min="10" max="500" step="10" value="70">
                    <small style="color: rgba(255,255,255,0.7); display: block; margin-top: 5px;">
                        Number of jumps needed before shop appears
                    </small>
                </div>
            </div>

            <div class="settings-section">
                <h3>🌙 Horror Mode</h3>
                <div class="setting-item">
                    <label>Enable Horror Mode:</label>
                    <input type="checkbox" id="horrorMode">
                </div>
                <div class="setting-item">
                    <label>Day Duration (seconds):</label>
                    <input type="number" id="dayDuration" min="10" max="120" step="5" value="30">
                </div>
                <div class="setting-item">
                    <label>Night Duration (seconds):</label>
                    <input type="number" id="nightDuration" min="10" max="120" step="5" value="20">
                </div>
            </div>

            <div class="settings-buttons">
                <button class="btn-save" onclick="saveSettingsFromModal()">Save</button>
                <button class="btn-reset" onclick="resetSettings()">Reset to Default</button>
                <button class="btn-cancel" onclick="closeSettings()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 50; // Increased from 40 to 50 for more zoom
        const COLS = canvas.width / GRID_SIZE;
        const ROWS = canvas.height / GRID_SIZE;

        // Character system
        let selectedCharacter = 'chick';
        const characters = {
            chick: { name: 'Golden Chick', emoji: '🐥' },
            goose: { name: 'Goose', emoji: '🦆' },
            ghost: { name: 'Ghost', emoji: '👻' },
            military: { name: 'Soldier', emoji: '🪖' },
            dog: { name: 'Emma', emoji: '🐕' }
        };

        // Character Powers
        let gooseHonksRemaining = 1; // Goose gets 1 honk per game
        let carsStoppedUntil = 0; // Timestamp when cars should start moving again
        let militaryLives = 2; // Military starts with 2 lives
        let ghostPhasing = false; // Ghost phasing through cars
        let ghostPhasingUntil = 0; // Timestamp when phasing ends
        let dogSpeedBoost = 1.008; // Emma (dog) is 0.8% faster (multiply movement by this)
        let militaryKnockedDown = false; // Military is knocked down after getting hit
        let militaryKnockdownTimer = 0; // Timer for knockdown animation

        // Shop and Power-ups
        let shopUnlocked = false; // Shop unlocks at score 70
        let shopBuildingWorldY = null; // Position of shop building on map
        let shopBuildingX = 2; // Left side of map (column 2)
        let inShop = false; // True when player is in the shop interface
        let shopCooldown = 0; // Timestamp when player can enter shop again
        let powerUpSpeedBoost = 1.0; // Speed boost multiplier (1.009 when active)
        let powerUpSpeedBoostActive = false;
        let powerUpFreezeTime = false;
        let powerUpFreezeUntil = 0;
        let powerUpExtraLives = 0; // Additional lives from power-up
        let powerUpAirstrikeOwned = false;
        let powerUpAirstrikeActive = false;
        let airstrikeAnimating = false;
        let airstrikeY = 0; // Missile Y position
        let airstrikeExplosionTime = 0;
        let carsGoneUntil = 0; // Timestamp when cars should respawn after airstrike
        let airstrikeCodeEntered = false;
        let airstrikeCodeInput = '';
        let powerUpRainbowOwned = false; // Player has purchased Rainbow Road
        let rainbowRoadActive = false; // Rainbow road is currently spawned
        let rainbowRoadStartY = null; // Starting world Y position
        let rainbowRoadEndY = null; // Ending world Y position (startY - 20)
        let rainbowRoadColumn = null; // Which column (X position) the rainbow road is on
        let powerUpTsunamiOwned = false; // Player has purchased Tsunami
        let tsunamiActive = false; // Tsunami is currently active
        let tsunamiEndTime = 0; // Timestamp when tsunami ends
        let tsunamiX = 0; // Current X position of the tsunami wave
        let tsunamiDirection = 1; // 1 for left-to-right, -1 for right-to-left

        // Game Settings (configurable) - MUST BE DEFINED FIRST
        let gameSettings = {
            // Vehicle settings
            vehicleDensityMin: 1,
            vehicleDensityMax: 2,
            vehicleSpeedMin: 0.02,
            vehicleSpeedMax: 0.05,
            vehicleSpawnFrequency: 3, // Every X rows

            // Road lane settings
            minLanes: 1,
            maxLanes: 5,

            // Flight power-up settings
            coinsForFlight: 5,
            flightDuration: 5000, // milliseconds
            flightMovementDelay: 150, // milliseconds between moves when flying

            // Coin settings
            coinSpawnMin: 5,
            coinSpawnMax: 18,
            coinSpawnDistanceMin: 8,
            coinSpawnDistanceMax: 12,

            // Game difficulty
            winScore: 333,
            gridSize: 50,

            // Animation settings
            hopSpeed: 0.008,
            hopHeight: 15,
            cameraSmoothing: 0.15,

            // Wolf chase settings
            wolfChaseDelay: 3000, // milliseconds before wolf starts chasing
            wolfSpeed: 2, // jumps per second
            wolfSpawnDistance: 5, // rows behind chicken when teleporting

            // Shop settings
            shopUnlockScore: 70, // Score needed for shop to appear

            // Horror mode settings
            horrorMode: false,
            dayDuration: 30000, // milliseconds for daytime
            nightDuration: 20000 // milliseconds for nighttime
        };

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('crossyRoadSettings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    gameSettings = { ...gameSettings, ...parsed };
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('crossyRoadSettings', JSON.stringify(gameSettings));
        }

        // Load settings on startup
        loadSettings();

        // Game state
        let gameOver = false;
        let score = 0;
        let highScore = localStorage.getItem('crossyRoadHighScore') || 0;
        let cameraY = 0; // Camera offset for scrolling
        let minRowGenerated = 0; // Track the furthest row we've generated (going into negatives)
        let startingWorldY = ROWS - 2; // Starting position
        let maxWorldY = ROWS - 2; // Track the furthest the player has gone (lowest value)

        // Coin system
        let coins = 0;
        let coinObjects = []; // Array to store coin positions
        let nextCoinSpawn = Math.floor(Math.random() * (gameSettings.coinSpawnMax - gameSettings.coinSpawnMin + 1)) + gameSettings.coinSpawnMin;

        // Flight system
        let isFlying = false;
        let flightTimeRemaining = 0;
        let lastMoveTime = 0; // Track last movement time for flight speed limit

        // Wolf chase system
        let wolfWorldY = ROWS - 1; // Wolf's actual world Y position (starts at bottom of initial screen)
        let wolfX = Math.floor(COLS / 2); // Wolf's X position (smooth tracking)
        let wolfRenderX = Math.floor(COLS / 2); // Wolf's smooth render X position
        let timeSinceLastForwardMove = 0;
        let wolfChasing = false;

        // Horror mode / Day-Night cycle
        let isNightTime = false;
        let dayNightTimer = 0;
        let timeOfDayTransition = 0; // 0 = full day, 1 = full night (for smooth transitions)
        let monsters = []; // Array for all monsters (bats, zombies, etc.)

        // Player
        let player = {
            x: Math.floor(COLS / 2),
            y: ROWS - 2,
            worldY: ROWS - 2, // Actual position in the world
            renderX: Math.floor(COLS / 2), // Smooth rendering position
            renderWorldY: ROWS - 2, // Smooth rendering position
            color: '#FFD700',
            isHopping: false,
            hopProgress: 0,
            hopHeight: 0
        };

        // Roads and cars
        let roads = [];
        let cars = [];

        // Initialize game
        function init() {
            // Create initial roads with random lane counts
            let currentRow = 0;
            while (currentRow < ROWS) {
                if (currentRow % gameSettings.vehicleSpawnFrequency === 0 && currentRow !== ROWS - 2) {
                    const laneRange = gameSettings.maxLanes - gameSettings.minLanes + 1;
                    const laneCount = Math.floor(Math.random() * laneRange) + gameSettings.minLanes;
                    roads.push({
                        row: currentRow,
                        laneCount: laneCount,
                        direction: Math.random() > 0.5 ? 1 : -1
                    });
                    currentRow += laneCount; // Skip rows that are part of this road
                } else {
                    currentRow++;
                }
            }

            // Create initial cars (distributed across lanes)
            roads.forEach(road => {
                const numCars = Math.floor(Math.random() * (gameSettings.vehicleDensityMax - gameSettings.vehicleDensityMin + 1)) + gameSettings.vehicleDensityMin;
                for (let i = 0; i < numCars; i++) {
                    const vehicleType = getRandomVehicleType();
                    const speedRange = gameSettings.vehicleSpeedMax - gameSettings.vehicleSpeedMin;
                    // Pick a random lane within this road
                    const lane = Math.floor(Math.random() * road.laneCount);
                    const laneY = road.row + lane;
                    cars.push({
                        x: Math.random() * COLS,
                        y: laneY,
                        width: vehicleType.width,
                        speed: (Math.random() * speedRange + gameSettings.vehicleSpeedMin) * road.direction,
                        color: getRandomCarColor(),
                        type: vehicleType.type
                    });
                }
            });

            updateScoreDisplay();
        }

        // Generate new roads as player progresses
        function generateNewRoads() {
            const currentTopRow = Math.floor(cameraY);

            // Generate roads ahead of the camera (going into negative rows)
            while (minRowGenerated > currentTopRow - 10) {
                if (minRowGenerated % gameSettings.vehicleSpawnFrequency === 0 && minRowGenerated !== startingWorldY) {
                    const laneRange = gameSettings.maxLanes - gameSettings.minLanes + 1;
                    const laneCount = Math.floor(Math.random() * laneRange) + gameSettings.minLanes;
                    const newRoad = {
                        row: minRowGenerated,
                        laneCount: laneCount,
                        direction: Math.random() > 0.5 ? 1 : -1
                    };
                    roads.push(newRoad);

                    // Add cars to the new road (distributed across lanes)
                    // BUT NOT during airstrike period!
                    if (Date.now() >= carsGoneUntil) {
                        const numCars = Math.floor(Math.random() * (gameSettings.vehicleDensityMax - gameSettings.vehicleDensityMin + 1)) + gameSettings.vehicleDensityMin;
                        for (let i = 0; i < numCars; i++) {
                            const vehicleType = getRandomVehicleType();
                            const speedRange = gameSettings.vehicleSpeedMax - gameSettings.vehicleSpeedMin;
                            // Pick a random lane within this road
                            const lane = Math.floor(Math.random() * laneCount);
                            const laneY = newRoad.row + lane;

                            // Check if this lane is part of the Rainbow Road
                            const isOnRainbowRoad = rainbowRoadActive &&
                                                   laneY <= rainbowRoadStartY &&
                                                   laneY >= rainbowRoadEndY;

                            // Don't spawn cars on Rainbow Road
                            if (!isOnRainbowRoad) {
                                cars.push({
                                    x: Math.random() * COLS,
                                    y: laneY,
                                    width: vehicleType.width,
                                    speed: (Math.random() * speedRange + gameSettings.vehicleSpeedMin) * newRoad.direction,
                                    color: getRandomCarColor(),
                                    type: vehicleType.type,
                                    tumbling: false,
                                    tumbleRotation: 0,
                                    tumbleSpeed: 0
                                });
                            }
                        }
                    }
                    minRowGenerated -= laneCount; // Skip rows that are part of this road
                } else {
                    minRowGenerated--;
                }
            }

            // Clean up old roads and cars that are far behind
            const maxVisibleRow = currentTopRow + ROWS + 10;
            roads = roads.filter(road => road.row < maxVisibleRow);
            cars = cars.filter(car => car.y < maxVisibleRow);
        }

        function getRandomCarColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6', '#1ABC9C'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function getRandomVehicleType() {
            const types = [
                { type: 'sedan', width: 1 },
                { type: 'suv', width: 1 },
                { type: 'sports', width: 1 },
                { type: 'van', width: 1.5 },
                { type: 'pickup', width: 1.3 },
                { type: 'delivery', width: 2 },
                { type: 'semi', width: 2.5 }
            ];
            return types[Math.floor(Math.random() * types.length)];
        }

        // Update game
        function update(deltaTime) {
            if (gameOver || inShop) return; // Pause game when in shop

            // Smooth player position interpolation (with dog speed boost if applicable)
            let playerLerpFactor = 0.25;
            if (selectedCharacter === 'dog') {
                playerLerpFactor *= dogSpeedBoost; // Dog moves 0.8% faster
            }
            // Apply speed boost power-up
            if (powerUpSpeedBoostActive) {
                playerLerpFactor *= powerUpSpeedBoost; // 0.9% speed boost
            }
            player.renderX += (player.x - player.renderX) * playerLerpFactor;
            player.renderWorldY += (player.worldY - player.renderWorldY) * playerLerpFactor;

            // Update military knockdown timer
            if (militaryKnockedDown) {
                militaryKnockdownTimer += deltaTime;
                if (militaryKnockdownTimer >= 1500) { // 1.5 seconds knockdown
                    militaryKnockedDown = false;
                    militaryKnockdownTimer = 0;
                }
            }

            // Update flight timer
            if (isFlying) {
                flightTimeRemaining -= deltaTime;
                if (flightTimeRemaining <= 0) {
                    isFlying = false;
                    flightTimeRemaining = 0;
                    document.getElementById('flightDisplay').classList.remove('active');
                } else {
                    // Update flight timer display
                    document.getElementById('flightTime').textContent = (flightTimeRemaining / 1000).toFixed(1);
                    document.getElementById('flightDisplay').classList.add('active');
                }
            }

            // Update day/night cycle (horror mode)
            if (gameSettings.horrorMode) {
                dayNightTimer += deltaTime;

                const currentCycleDuration = isNightTime ? gameSettings.nightDuration : gameSettings.dayDuration;

                // Smooth transition effect (fade over last 3 seconds of each period)
                const transitionDuration = 3000;
                const timeRemaining = currentCycleDuration - dayNightTimer;

                if (timeRemaining <= transitionDuration) {
                    // Transitioning to next period
                    const transitionProgress = 1 - (timeRemaining / transitionDuration);
                    timeOfDayTransition = isNightTime ? 1 - transitionProgress : transitionProgress;
                } else {
                    // Fully in current period
                    timeOfDayTransition = isNightTime ? 1 : 0;
                }

                // Switch periods
                if (dayNightTimer >= currentCycleDuration) {
                    isNightTime = !isNightTime;
                    dayNightTimer = 0;

                    // Spawn monsters when night begins
                    if (isNightTime) {
                        spawnNightMonsters();
                    } else {
                        // Clear monsters when day begins
                        monsters = [];
                    }
                }

                // Update monsters
                updateMonsters(deltaTime);
            }

            // Update wolf chase timer when not chasing
            if (!wolfChasing) {
                timeSinceLastForwardMove += deltaTime;

                // If timer expires, teleport wolf behind chicken and start chasing
                if (timeSinceLastForwardMove >= gameSettings.wolfChaseDelay) {
                    wolfWorldY = player.worldY + gameSettings.wolfSpawnDistance;
                    wolfX = player.x; // Start at player's X position
                    wolfRenderX = player.x; // Initialize render position
                    wolfChasing = true;
                    timeSinceLastForwardMove = 0;
                }
            }

            // Once wolf starts chasing, he moves forward in world space
            if (wolfChasing) {
                // Wolf moves forward (decreasing worldY) at configured jumps per second
                const wolfMovement = (gameSettings.wolfSpeed / 1000) * deltaTime;
                wolfWorldY -= wolfMovement;

                // Wolf tracks player's X position with a delay (smooth lerp)
                const wolfXLerpFactor = 0.05; // Lower = more delay/smoother
                wolfX += (player.x - wolfX) * wolfXLerpFactor;

                // Check if wolf caught the chicken (using actual positions) - but not in shop
                if (wolfWorldY <= player.worldY && Math.abs(wolfX - player.x) < 0.5 && !inShop) {
                    endGame();
                }

                // Check if chicken has moved far enough forward to outpace the wolf
                // Wolf stops chasing when chicken gets far enough ahead
                const distanceBehind = wolfWorldY - player.worldY;
                if (distanceBehind > gameSettings.wolfSpawnDistance * 2) {
                    // Chicken escaped - wolf stops chasing and timer resets
                    wolfChasing = false;
                    timeSinceLastForwardMove = 0;
                }
            }

            // Smooth wolf render position for drawing
            const wolfRenderLerpFactor = 0.25;
            wolfRenderX += (wolfX - wolfRenderX) * wolfRenderLerpFactor;

            // Update hopping animation (or flying animation)
            if (player.isHopping) {
                player.hopProgress += deltaTime * 0.008; // Hop speed
                if (player.hopProgress >= 1) {
                    player.hopProgress = 0;
                    player.isHopping = false;
                    if (!isFlying) {
                        player.hopHeight = 0;
                    }
                } else {
                    // Parabolic hop using sine wave (or floating effect when flying)
                    if (isFlying) {
                        // Gentle floating animation when flying
                        player.hopHeight = 25 + Math.sin(player.hopProgress * Math.PI * 2) * 5;
                    } else {
                        player.hopHeight = Math.sin(player.hopProgress * Math.PI) * 15;
                    }
                }
            } else if (isFlying) {
                // Maintain flying height even when not moving
                player.hopHeight = 25;
            }

            // Smooth camera interpolation (lerp) - prevents jerky movement
            const targetCameraY = player.renderWorldY - (ROWS - 5);
            const lerpFactor = 0.15; // Smoothness factor (lower = smoother but slower)
            cameraY += (targetCameraY - cameraY) * lerpFactor;

            // Generate new roads as needed
            generateNewRoads();

            // Update ghost phasing status
            if (ghostPhasing && Date.now() >= ghostPhasingUntil) {
                ghostPhasing = false;
            }

            // Deactivate Rainbow Road if player has passed beyond it
            if (rainbowRoadActive && player.worldY < rainbowRoadEndY) {
                rainbowRoadActive = false;
                rainbowRoadStartY = null;
                rainbowRoadEndY = null;
                rainbowRoadColumn = null;
            }

            // Move cars with delta time for smooth frame-independent movement
            const timeScale = deltaTime / 16.67; // Normalize to 60fps

            // Check if cars should be stopped (goose honk power or freeze time power-up)
            const carsShouldStop = Date.now() < carsStoppedUntil || powerUpFreezeTime;

            if (!carsShouldStop) {
                cars.forEach(car => {
                    car.x += car.speed * timeScale;

                    // Wrap around
                    if (car.speed > 0 && car.x > COLS + 2) {
                        car.x = -car.width - 2;
                    } else if (car.speed < 0 && car.x < -car.width - 2) {
                        car.x = COLS + 2;
                    }
                });
            }

            // Remove any cars that are on the Rainbow Road (continuous filtering)
            if (rainbowRoadActive) {
                cars = cars.filter(car => {
                    const carY = Math.floor(car.y);
                    const isOnRainbowRoad = carY <= rainbowRoadStartY && carY >= rainbowRoadEndY;
                    return !isOnRainbowRoad; // Keep cars that are NOT on rainbow road
                });
            }

            // Tsunami: make cars tumble when wave hits them
            if (tsunamiActive) {
                cars.forEach(car => {
                    const carCenterX = car.x + car.width / 2;
                    const waveReached = tsunamiDirection === 1 ?
                        (carCenterX <= tsunamiX && carCenterX >= tsunamiX - 2) :
                        (carCenterX >= tsunamiX && carCenterX <= tsunamiX + 2);

                    // If wave just reached this car, start tumbling
                    if (waveReached && !car.tumbling) {
                        car.tumbling = true;
                        car.tumbleRotation = 0;
                        // Push speed to the side (same direction as wave)
                        car.tumbleSpeed = tsunamiDirection * 0.8;
                    }

                    // Update tumbling cars
                    if (car.tumbling) {
                        car.x += car.tumbleSpeed * timeScale;
                        car.tumbleRotation += 0.3 * timeScale; // Rotate as it tumbles
                        car.tumbleSpeed *= 0.98; // Slow down over time
                    }
                });

                // Remove cars that have tumbled off screen
                cars = cars.filter(car => {
                    if (!car.tumbling) return true;
                    return car.x > -5 && car.x < COLS + 5;
                });
            }

            // Check coin collection
            coinObjects.forEach(coin => {
                if (!coin.collected && player.worldY === coin.y && player.x === coin.x) {
                    coin.collected = true;
                    coins++;

                    // Check if player has collected enough coins for flight
                    if (coins >= gameSettings.coinsForFlight && !isFlying) {
                        isFlying = true;
                        flightTimeRemaining = gameSettings.flightDuration;
                        coins = 0; // Reset coins after activating flight
                    }

                    updateScoreDisplay();
                }
            });

            // Clean up old collected coins and coins far behind the player
            coinObjects = coinObjects.filter(coin => !coin.collected && coin.y > cameraY - 5);

            // Shop unlock at configured score
            if (score >= gameSettings.shopUnlockScore && !shopUnlocked) {
                shopUnlocked = true;
                // Spawn shop building ahead of player (5 rows forward on grass)
                shopBuildingWorldY = player.worldY - 5; // 5 rows ahead
            }

            // Check if player enters shop building (larger detection area)
            if (shopUnlocked && shopBuildingWorldY !== null && !inShop && Date.now() >= shopCooldown) {
                const distanceY = Math.abs(player.worldY - shopBuildingWorldY);
                const distanceX = Math.abs(player.x - shopBuildingX);

                // Enter shop if within 2 tiles of building center
                if (distanceY < 2 && distanceX < 2) {
                    enterShop();
                }
            }

            // Update freeze time power-up
            if (powerUpFreezeTime && Date.now() >= powerUpFreezeUntil) {
                powerUpFreezeTime = false;
            }

            // Update tsunami wave animation
            if (tsunamiActive) {
                // Move tsunami wave across screen
                tsunamiX += tsunamiDirection * deltaTime * 0.3; // Speed of wave

                // Check if tsunami has ended
                if (Date.now() >= tsunamiEndTime) {
                    tsunamiActive = false;
                }
            }

            // Update airstrike animation
            if (airstrikeAnimating) {
                airstrikeY += deltaTime * 1.5; // Fast missile speed

                // Check if missile reached bottom
                if (airstrikeY >= canvas.height + 50) {
                    // Explosion! Remove all cars and wolf
                    airstrikeAnimating = false;
                    airstrikeExplosionTime = Date.now();
                    carsGoneUntil = Date.now() + 9500; // Cars gone for 9.5 seconds
                    cars = []; // Clear all cars
                    powerUpAirstrikeActive = true;

                    // Remove wolf for 10 seconds
                    wolfChasing = false;
                    wolfWorldY = player.worldY + 999; // Send wolf far away
                    setTimeout(() => {
                        wolfChasing = false;
                        timeSinceLastForwardMove = 0; // Reset wolf chase timer
                    }, 10000);

                    // Reset airstrike ownership so player can buy again
                    powerUpAirstrikeOwned = false;
                    const airstrikeShopItem = document.querySelector('[data-powerup="airstrike"]');
                    if (airstrikeShopItem) {
                        airstrikeShopItem.classList.remove('purchased');
                    }
                    // Hide code panel
                    document.getElementById('airstrikeCodePanel').style.display = 'none';
                }
            }

            // Respawn cars after airstrike
            if (powerUpAirstrikeActive && Date.now() >= carsGoneUntil) {
                powerUpAirstrikeActive = false;
                // Regenerate cars for existing roads
                roads.forEach(road => {
                    if (road.laneCount > 1) {
                        // Multi-lane road
                        road.lanes = [];
                        for (let i = 0; i < road.laneCount; i++) {
                            const laneDirection = (i % 2 === 0) ? 1 : -1;
                            const vehicleCount = Math.floor(Math.random() * 2) + 1;
                            const vehicles = [];

                            for (let v = 0; v < vehicleCount; v++) {
                                const vehicleType = getRandomVehicleType();
                                const vehicleX = (Math.random() * COLS * 2) - COLS;
                                vehicles.push({
                                    x: vehicleX,
                                    type: vehicleType.type,
                                    width: vehicleType.width,
                                    speed: (Math.random() * 0.03 + 0.02) * laneDirection,
                                    color: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#FFD93D'][Math.floor(Math.random() * 6)]
                                });
                            }

                            road.lanes.push({
                                direction: laneDirection,
                                vehicles: vehicles
                            });
                        }

                        // Flatten vehicles for main cars array
                        road.lanes.forEach((lane, laneIndex) => {
                            lane.vehicles.forEach(vehicle => {
                                cars.push({
                                    ...vehicle,
                                    y: road.row + laneIndex,
                                    lane: laneIndex
                                });
                            });
                        });
                    }
                });
            }

            // Check collision
            checkCollision();
        }

        // Draw game
        function draw() {
            // Clear canvas with gradient sky (day or night)
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

            if (gameSettings.horrorMode) {
                // Interpolate between day and night sky colors
                const dayTop = [135, 206, 235]; // #87CEEB
                const dayBottom = [176, 224, 230]; // #B0E0E6
                const nightTop = [10, 10, 30]; // Dark blue
                const nightBottom = [25, 25, 50]; // Slightly lighter dark blue

                const r1 = Math.round(dayTop[0] + (nightTop[0] - dayTop[0]) * timeOfDayTransition);
                const g1 = Math.round(dayTop[1] + (nightTop[1] - dayTop[1]) * timeOfDayTransition);
                const b1 = Math.round(dayTop[2] + (nightTop[2] - dayTop[2]) * timeOfDayTransition);

                const r2 = Math.round(dayBottom[0] + (nightBottom[0] - dayBottom[0]) * timeOfDayTransition);
                const g2 = Math.round(dayBottom[1] + (nightBottom[1] - dayBottom[1]) * timeOfDayTransition);
                const b2 = Math.round(dayBottom[2] + (nightBottom[2] - dayBottom[2]) * timeOfDayTransition);

                skyGradient.addColorStop(0, `rgb(${r1}, ${g1}, ${b1})`);
                skyGradient.addColorStop(1, `rgb(${r2}, ${g2}, ${b2})`);
            } else {
                skyGradient.addColorStop(0, '#87CEEB');
                skyGradient.addColorStop(1, '#B0E0E6');
            }

            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate visible rows
            const startRow = Math.floor(cameraY);
            const endRow = startRow + ROWS + 1;

            // Draw grass and roads with 2.5D effect
            for (let worldRow = startRow; worldRow < endRow; worldRow++) {
                const screenY = (worldRow - cameraY) * GRID_SIZE;
                if (screenY < -GRID_SIZE || screenY > canvas.height) continue;

                // Check if this row is part of the Rainbow Road
                const isRainbowRoad = rainbowRoadActive &&
                                      worldRow <= rainbowRoadStartY &&
                                      worldRow >= rainbowRoadEndY;

                if (isRainbowRoad) {
                    // Draw rainbow road (colorful grass lane)
                    drawRainbowRoad(screenY, worldRow);
                } else {
                    // Check if this row is part of a multi-lane road
                    const road = roads.find(road => worldRow >= road.row && worldRow < road.row + road.laneCount);
                    if (road) {
                        const laneIndex = worldRow - road.row;
                        draw3DRoad(screenY, road.laneCount, laneIndex, road.direction);
                    } else {
                        draw3DGrass(screenY);
                    }
                }
            }

            // Draw cars with camera offset and 2.5D effect
            cars.forEach(car => {
                const screenY = (car.y - cameraY) * GRID_SIZE;
                if (screenY < -GRID_SIZE || screenY > canvas.height) return;

                const facingRight = car.speed > 0;
                const x = car.x * GRID_SIZE;
                const width = car.width * GRID_SIZE;

                // Apply rotation if car is tumbling
                if (car.tumbling) {
                    ctx.save();
                    ctx.translate(x + width / 2, screenY + GRID_SIZE / 2);
                    ctx.rotate(car.tumbleRotation);
                    ctx.translate(-(x + width / 2), -(screenY + GRID_SIZE / 2));
                }

                switch(car.type) {
                    case 'sedan':
                        drawSedan(x, screenY, width, car.color, facingRight);
                        break;
                    case 'suv':
                        drawSUV(x, screenY, width, car.color, facingRight);
                        break;
                    case 'sports':
                        drawSportsCar(x, screenY, width, car.color, facingRight);
                        break;
                    case 'van':
                        drawVan(x, screenY, width, car.color, facingRight);
                        break;
                    case 'pickup':
                        drawPickup(x, screenY, width, car.color, facingRight);
                        break;
                    case 'delivery':
                        drawDeliveryTruck(x, screenY, width, car.color, facingRight);
                        break;
                    case 'semi':
                        drawSemiTruck(x, screenY, width, car.color, facingRight);
                        break;
                }

                // Restore context if we rotated
                if (car.tumbling) {
                    ctx.restore();
                }
            });

            // Draw sun/moon in top right corner
            drawSunMoon();

            // Draw coins with camera offset
            coinObjects.forEach(coin => {
                if (!coin.collected) {
                    const coinScreenY = (coin.y - cameraY) * GRID_SIZE;
                    if (coinScreenY >= -GRID_SIZE && coinScreenY <= canvas.height) {
                        drawCoin(coin.x * GRID_SIZE + GRID_SIZE / 2, coinScreenY + GRID_SIZE / 2);
                    }
                }
            });

            // Draw wolf chasing from behind
            // Wolf has his own world Y position and X position (tracks with delay)
            const wolfScreenY = (wolfWorldY - cameraY) * GRID_SIZE;
            // Only draw if wolf is on screen
            if (wolfScreenY >= -GRID_SIZE && wolfScreenY <= canvas.height + GRID_SIZE) {
                drawWolf(wolfRenderX * GRID_SIZE + GRID_SIZE / 2, wolfScreenY + GRID_SIZE / 2);
            }

            // Draw monsters (horror mode)
            if (gameSettings.horrorMode && monsters.length > 0) {
                drawMonsters();
            }

            // Draw shop building if unlocked
            if (shopUnlocked && shopBuildingWorldY !== null) {
                const shopScreenY = (shopBuildingWorldY - cameraY) * GRID_SIZE;
                if (shopScreenY >= -GRID_SIZE * 3 && shopScreenY <= canvas.height) {
                    drawShopBuilding(shopBuildingX * GRID_SIZE, shopScreenY);
                }
            }

            // Draw player (chicken) with camera offset using smooth render positions and hop offset
            const playerScreenY = (player.renderWorldY - cameraY) * GRID_SIZE;
            drawCharacter(player.renderX * GRID_SIZE + GRID_SIZE / 2, playerScreenY + GRID_SIZE / 2 - player.hopHeight, isFlying);

            // Draw airstrike missile
            if (airstrikeAnimating) {
                const missileX = canvas.width / 2;
                const missileY = airstrikeY;
                const missileWidth = 30;
                const missileHeight = 80;

                // Missile body
                ctx.fillStyle = '#2a2a2a';
                ctx.beginPath();
                ctx.moveTo(missileX, missileY - missileHeight / 2);
                ctx.lineTo(missileX - missileWidth / 2, missileY + missileHeight / 3);
                ctx.lineTo(missileX + missileWidth / 2, missileY + missileHeight / 3);
                ctx.closePath();
                ctx.fill();

                // Missile body rectangle
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(missileX - missileWidth / 2, missileY - missileHeight / 3, missileWidth, missileHeight / 2);

                // Red warhead
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.moveTo(missileX, missileY - missileHeight / 2);
                ctx.lineTo(missileX - missileWidth / 3, missileY - missileHeight / 6);
                ctx.lineTo(missileX + missileWidth / 3, missileY - missileHeight / 6);
                ctx.closePath();
                ctx.fill();

                // Fins
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.moveTo(missileX - missileWidth / 2, missileY + missileHeight / 4);
                ctx.lineTo(missileX - missileWidth, missileY + missileHeight / 3);
                ctx.lineTo(missileX - missileWidth / 2, missileY + missileHeight / 3);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(missileX + missileWidth / 2, missileY + missileHeight / 4);
                ctx.lineTo(missileX + missileWidth, missileY + missileHeight / 3);
                ctx.lineTo(missileX + missileWidth / 2, missileY + missileHeight / 3);
                ctx.closePath();
                ctx.fill();

                // Flame trail
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(missileX, missileY + missileHeight / 3, 15, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(missileX, missileY + missileHeight / 3, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(missileX, missileY + missileHeight / 3, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw explosion effect for 2 seconds after impact
            const timeSinceExplosion = Date.now() - airstrikeExplosionTime;
            if (powerUpAirstrikeActive && timeSinceExplosion < 2000) {
                const explosionProgress = timeSinceExplosion / 2000;
                const explosionRadius = 200 * (1 - explosionProgress) + 500 * explosionProgress;
                const explosionAlpha = 1 - explosionProgress;

                // Multiple explosion circles
                for (let i = 0; i < 3; i++) {
                    const offset = i * 100;
                    const radius = explosionRadius - offset;

                    if (i === 0) {
                        ctx.fillStyle = `rgba(255, 68, 68, ${explosionAlpha * 0.6})`;
                    } else if (i === 1) {
                        ctx.fillStyle = `rgba(255, 170, 0, ${explosionAlpha * 0.4})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 255, 0, ${explosionAlpha * 0.2})`;
                    }

                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw HUGE tsunami wave
            if (tsunamiActive) {
                const waveX = tsunamiX * GRID_SIZE;
                const waveWidth = 200; // Much wider wave
                const time = Date.now() * 0.003;

                // Draw massive wave shadow/base
                const shadowGradient = ctx.createLinearGradient(
                    waveX - waveWidth, 0,
                    waveX + waveWidth, 0
                );

                if (tsunamiDirection === 1) {
                    shadowGradient.addColorStop(0, 'rgba(0, 50, 100, 0)');
                    shadowGradient.addColorStop(0.5, 'rgba(0, 80, 150, 0.4)');
                    shadowGradient.addColorStop(1, 'rgba(0, 100, 180, 0)');
                } else {
                    shadowGradient.addColorStop(0, 'rgba(0, 100, 180, 0)');
                    shadowGradient.addColorStop(0.5, 'rgba(0, 80, 150, 0.4)');
                    shadowGradient.addColorStop(1, 'rgba(0, 50, 100, 0)');
                }

                ctx.fillStyle = shadowGradient;
                ctx.fillRect(waveX - waveWidth, 0, waveWidth * 2, canvas.height);

                // Draw the main massive wave with curves
                for (let y = 0; y < canvas.height; y += 5) {
                    const waveHeight = Math.sin(y * 0.05 + time) * 40 + 60;
                    const waveOffset = Math.sin(y * 0.03 + time * 1.5) * 20;

                    // Main wave body
                    const mainGradient = ctx.createLinearGradient(
                        waveX - waveHeight + waveOffset, y,
                        waveX + waveHeight + waveOffset, y
                    );

                    if (tsunamiDirection === 1) {
                        mainGradient.addColorStop(0, 'rgba(0, 119, 190, 0.1)');
                        mainGradient.addColorStop(0.2, 'rgba(0, 150, 255, 0.7)');
                        mainGradient.addColorStop(0.4, 'rgba(30, 180, 255, 0.95)');
                        mainGradient.addColorStop(0.6, 'rgba(100, 200, 255, 0.9)');
                        mainGradient.addColorStop(0.8, 'rgba(173, 216, 230, 0.7)');
                        mainGradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    } else {
                        mainGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                        mainGradient.addColorStop(0.2, 'rgba(173, 216, 230, 0.7)');
                        mainGradient.addColorStop(0.4, 'rgba(100, 200, 255, 0.9)');
                        mainGradient.addColorStop(0.6, 'rgba(30, 180, 255, 0.95)');
                        mainGradient.addColorStop(0.8, 'rgba(0, 150, 255, 0.7)');
                        mainGradient.addColorStop(1, 'rgba(0, 119, 190, 0.1)');
                    }

                    ctx.fillStyle = mainGradient;
                    ctx.fillRect(waveX - waveHeight + waveOffset, y, waveHeight * 2, 5);
                }

                // Add dramatic foam/spray particles
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                for (let i = 0; i < 50; i++) {
                    const particleY = (i / 50) * canvas.height;
                    const particleOffset = Math.sin(time + i * 0.5) * 60 + Math.cos(time * 1.3 + i) * 30;
                    const particleX = waveX + particleOffset;
                    const size = 3 + Math.sin(time * 2 + i) * 2;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Add water droplets flying off
                for (let i = 0; i < 30; i++) {
                    const dropY = Math.random() * canvas.height;
                    const dropOffset = Math.sin(time * 3 + i) * 100 + Math.random() * 50;
                    const dropX = waveX + (tsunamiDirection * dropOffset);
                    const dropSize = 2 + Math.random() * 3;
                    ctx.fillStyle = `rgba(100, 200, 255, ${0.5 + Math.random() * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(dropX, dropY, dropSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Add white crest at the top of wave
                const crestGradient = ctx.createLinearGradient(waveX - 80, 0, waveX + 80, 0);
                crestGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                crestGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                crestGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                for (let y = 0; y < canvas.height; y += 20) {
                    const crestOffset = Math.sin(y * 0.1 + time * 2) * 30;
                    ctx.fillStyle = crestGradient;
                    ctx.fillRect(waveX - 80 + crestOffset, y, 160, 15);
                }
            }
        }

        // Helper function to darken a color for night time
        function getNightColor(dayColor, nightDarkenFactor = 0.3) {
            if (!gameSettings.horrorMode) return dayColor;

            // Parse hex color
            const hex = dayColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            // Darken for night
            const nightR = Math.round(r * nightDarkenFactor);
            const nightG = Math.round(g * nightDarkenFactor);
            const nightB = Math.round(b * nightDarkenFactor);

            // Interpolate
            const finalR = Math.round(r + (nightR - r) * timeOfDayTransition);
            const finalG = Math.round(g + (nightG - g) * timeOfDayTransition);
            const finalB = Math.round(b + (nightB - b) * timeOfDayTransition);

            return `rgb(${finalR}, ${finalG}, ${finalB})`;
        }

        // Draw 3D road with perspective
        function draw3DRoad(y, laneCount, laneIndex, direction) {
            // Base road
            const roadGradient = ctx.createLinearGradient(0, y, 0, y + GRID_SIZE);
            roadGradient.addColorStop(0, getNightColor('#3a3a3a', 0.5));
            roadGradient.addColorStop(0.5, getNightColor('#4a4a4a', 0.5));
            roadGradient.addColorStop(1, getNightColor('#2a2a2a', 0.5));
            ctx.fillStyle = roadGradient;
            ctx.fillRect(0, y, canvas.width, GRID_SIZE);

            // Road edge highlights for 3D effect (only on top/bottom edges of entire road)
            if (laneIndex === 0) {
                // Top edge of the road
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(0, y, canvas.width, 2);
            }
            if (laneIndex === laneCount - 1) {
                // Bottom edge of the road
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, y + GRID_SIZE - 2, canvas.width, 2);
            }

            // Lane markings
            if (laneCount === 1) {
                // Single lane - no lane markings (all cars go same direction)
            } else {
                // Multi-lane roads - add white dashed lines between lanes
                if (laneIndex < laneCount - 1) {
                    // Draw lane divider at bottom of this lane
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 2;
                    ctx.shadowOffsetY = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, y + GRID_SIZE);
                    ctx.lineTo(canvas.width, y + GRID_SIZE);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                }
            }
        }

        // Draw 3D grass with texture
        function draw3DGrass(y) {
            // Base grass with gradient
            const grassGradient = ctx.createLinearGradient(0, y, 0, y + GRID_SIZE);
            grassGradient.addColorStop(0, getNightColor('#7CBA5C', 0.25));
            grassGradient.addColorStop(0.5, getNightColor('#6FB34C', 0.25));
            grassGradient.addColorStop(1, getNightColor('#5A9E3A', 0.25));
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, y, canvas.width, GRID_SIZE);

            // Grass texture (small strokes)
            ctx.strokeStyle = 'rgba(90, 158, 58, 0.4)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 8) {
                if (Math.random() > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(i, y + Math.random() * GRID_SIZE);
                    ctx.lineTo(i + 2, y + Math.random() * GRID_SIZE);
                    ctx.stroke();
                }
            }

            // Edge highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, y, canvas.width, 1);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, y + GRID_SIZE - 1, canvas.width, 1);
        }

        // Draw Rainbow Road - colorful safe lane
        function drawRainbowRoad(y, worldRow) {
            // Create rainbow gradient based on world position for animated effect
            const offset = (worldRow * 50 + Date.now() * 0.1) % 360;
            const gradient = ctx.createLinearGradient(0, y, canvas.width, y);

            // Add rainbow color stops
            for (let i = 0; i <= 6; i++) {
                const hue = (offset + i * 60) % 360;
                gradient.addColorStop(i / 6, `hsl(${hue}, 100%, 70%)`);
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, y, canvas.width, GRID_SIZE);

            // Add sparkle effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < canvas.width; i += 30) {
                const sparkleX = i + ((worldRow + Date.now() * 0.001) % 30);
                const sparkleY = y + ((worldRow * 13) % GRID_SIZE);
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Edge glow
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillRect(0, y, canvas.width, 2);
            ctx.fillRect(0, y + GRID_SIZE - 2, canvas.width, 2);
        }

        // Draw Sedan - standard 4-door car
        function drawSedan(x, y, width, color, facingRight) {
            const carWidth = width - 4;
            const carHeight = GRID_SIZE - 12;
            const carX = facingRight ? x + 2 : x - 2;
            const carY = y + 6;
            const depth = 7;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(carX - 2, carY + carHeight + 2, carWidth + 4, 3);

            // Car body - top
            ctx.fillStyle = shadeColor(color, 10);
            ctx.beginPath();
            ctx.moveTo(carX + carWidth * 0.25, carY + depth);
            ctx.lineTo(carX + carWidth * 0.3, carY);
            ctx.lineTo(carX + carWidth * 0.7, carY);
            ctx.lineTo(carX + carWidth * 0.75, carY + depth);
            ctx.closePath();
            ctx.fill();

            // Car body - front face
            ctx.fillStyle = color;
            ctx.fillRect(carX, carY + depth, carWidth, carHeight - depth);

            // Hood/trunk (depending on direction)
            const frontX = facingRight ? carX + carWidth * 0.75 : carX;
            const frontWidth = carWidth * 0.25;
            ctx.fillStyle = shadeColor(color, -10);
            ctx.fillRect(frontX, carY + depth, frontWidth, carHeight - depth);

            // Windshield
            const windX = facingRight ? carX + carWidth * 0.55 : carX + carWidth * 0.25;
            const windWidth = carWidth * 0.2;
            ctx.fillStyle = 'rgba(100, 180, 220, 0.7)';
            ctx.beginPath();
            ctx.moveTo(windX, carY + depth);
            ctx.lineTo(windX + windWidth * 0.2, carY + 2);
            ctx.lineTo(windX + windWidth * 0.8, carY + 2);
            ctx.lineTo(windX + windWidth, carY + depth);
            ctx.closePath();
            ctx.fill();
            ctx.fillRect(windX, carY + depth, windWidth, carHeight * 0.5);

            // Headlights/Taillights
            const lightX = facingRight ? carX + carWidth - 4 : carX + 2;
            ctx.fillStyle = facingRight ? '#FFFFCC' : '#FF3333';
            ctx.fillRect(lightX, carY + carHeight - 6, 3, 4);

            // Wheels
            const wheelY = carY + carHeight - 3;
            drawWheel(carX + carWidth * 0.2, wheelY);
            drawWheel(carX + carWidth * 0.75, wheelY);

            // Headlights (horror mode)
            drawHeadlights(carX, carY, carWidth, carHeight, facingRight);
        }

        // Draw SUV - taller vehicle
        function drawSUV(x, y, width, color, facingRight) {
            const carWidth = width - 4;
            const carHeight = GRID_SIZE - 8;
            const carX = facingRight ? x + 2 : x - 2;
            const carY = y + 4;
            const depth = 9;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(carX - 2, carY + carHeight + 2, carWidth + 4, 3);

            // Car body - top (taller roof)
            ctx.fillStyle = shadeColor(color, 15);
            ctx.beginPath();
            ctx.moveTo(carX + carWidth * 0.2, carY + depth);
            ctx.lineTo(carX + carWidth * 0.25, carY);
            ctx.lineTo(carX + carWidth * 0.75, carY);
            ctx.lineTo(carX + carWidth * 0.8, carY + depth);
            ctx.closePath();
            ctx.fill();

            // Car body - front
            ctx.fillStyle = color;
            ctx.fillRect(carX, carY + depth, carWidth, carHeight - depth);

            // Front grille
            const grillX = facingRight ? carX + carWidth * 0.85 : carX;
            ctx.fillStyle = '#333333';
            ctx.fillRect(grillX, carY + depth + 2, carWidth * 0.15, carHeight * 0.3);

            // Windows (larger for SUV)
            const windX = facingRight ? carX + carWidth * 0.5 : carX + carWidth * 0.25;
            const windWidth = carWidth * 0.3;
            ctx.fillStyle = 'rgba(100, 180, 220, 0.65)';
            ctx.beginPath();
            ctx.moveTo(windX, carY + depth);
            ctx.lineTo(windX + windWidth * 0.15, carY + 1);
            ctx.lineTo(windX + windWidth * 0.85, carY + 1);
            ctx.lineTo(windX + windWidth, carY + depth);
            ctx.closePath();
            ctx.fill();
            ctx.fillRect(windX, carY + depth, windWidth, carHeight * 0.55);

            // Lights
            const lightX = facingRight ? carX + carWidth - 4 : carX + 2;
            ctx.fillStyle = facingRight ? '#FFFFCC' : '#FF3333';
            ctx.fillRect(lightX, carY + carHeight - 8, 3, 5);

            // Wheels (larger)
            const wheelY = carY + carHeight - 3;
            drawWheel(carX + carWidth * 0.18, wheelY);
            drawWheel(carX + carWidth * 0.78, wheelY);

            // Headlights (horror mode)
            drawHeadlights(carX, carY, carWidth, carHeight, facingRight);
        }

        // Draw Sports Car - low and sleek
        function drawSportsCar(x, y, width, color, facingRight) {
            const carWidth = width - 4;
            const carHeight = GRID_SIZE - 16;
            const carX = facingRight ? x + 2 : x - 2;
            const carY = y + 8;
            const depth = 5;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(carX - 2, carY + carHeight + 2, carWidth + 4, 2);

            // Sleek top
            ctx.fillStyle = shadeColor(color, 20);
            ctx.beginPath();
            ctx.moveTo(carX + carWidth * 0.35, carY + depth);
            ctx.lineTo(carX + carWidth * 0.4, carY);
            ctx.lineTo(carX + carWidth * 0.65, carY);
            ctx.lineTo(carX + carWidth * 0.7, carY + depth);
            ctx.closePath();
            ctx.fill();

            // Body - very low profile
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(carX, carY + depth + 2);
            ctx.lineTo(carX + carWidth * 0.15, carY + depth);
            ctx.lineTo(carX + carWidth * 0.85, carY + depth);
            ctx.lineTo(carX + carWidth, carY + depth + 2);
            ctx.lineTo(carX + carWidth, carY + carHeight);
            ctx.lineTo(carX, carY + carHeight);
            ctx.closePath();
            ctx.fill();

            // Spoiler (if facing right)
            if (facingRight) {
                ctx.fillStyle = shadeColor(color, -20);
                ctx.fillRect(carX, carY + depth - 1, carWidth * 0.12, 2);
            } else {
                ctx.fillRect(carX + carWidth * 0.88, carY + depth - 1, carWidth * 0.12, 2);
            }

            // Small windshield
            const windX = facingRight ? carX + carWidth * 0.5 : carX + carWidth * 0.35;
            const windWidth = carWidth * 0.15;
            ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
            ctx.fillRect(windX, carY + depth + 1, windWidth, depth);

            // Headlights
            const lightX = facingRight ? carX + carWidth - 3 : carX + 2;
            ctx.fillStyle = facingRight ? '#FFFFEE' : '#FF0000';
            ctx.fillRect(lightX, carY + carHeight - 5, 2, 3);

            // Low-profile wheels
            const wheelY = carY + carHeight - 2;
            drawWheel(carX + carWidth * 0.2, wheelY);
            drawWheel(carX + carWidth * 0.75, wheelY);

            // Headlights (horror mode)
            drawHeadlights(carX, carY, carWidth, carHeight, facingRight);
        }

        // Draw Van
        function drawVan(x, y, width, color, facingRight) {
            const vanWidth = width - 4;
            const vanHeight = GRID_SIZE - 6;
            const vanX = facingRight ? x + 2 : x - 2;
            const vanY = y + 3;
            const depth = 10;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.fillRect(vanX - 2, vanY + vanHeight + 2, vanWidth + 4, 3);

            // Boxy top
            ctx.fillStyle = shadeColor(color, 10);
            ctx.fillRect(vanX + vanWidth * 0.15, vanY, vanWidth * 0.7, depth);

            // Body - tall and boxy
            ctx.fillStyle = color;
            ctx.fillRect(vanX, vanY + depth, vanWidth, vanHeight - depth);

            // Front panel
            const frontX = facingRight ? vanX + vanWidth * 0.85 : vanX;
            ctx.fillStyle = shadeColor(color, -15);
            ctx.fillRect(frontX, vanY + depth, vanWidth * 0.15, vanHeight - depth);

            // Windows
            const windX = facingRight ? vanX + vanWidth * 0.7 : vanX + vanWidth * 0.2;
            const windWidth = vanWidth * 0.15;
            ctx.fillStyle = 'rgba(100, 180, 220, 0.6)';
            ctx.fillRect(windX, vanY + depth + 2, windWidth, vanHeight * 0.35);

            // Side windows
            ctx.fillRect(vanX + vanWidth * 0.3, vanY + depth + 2, vanWidth * 0.4, vanHeight * 0.25);

            // Lights
            const lightX = facingRight ? vanX + vanWidth - 4 : vanX + 2;
            ctx.fillStyle = facingRight ? '#FFFFCC' : '#FF3333';
            ctx.fillRect(lightX, vanY + vanHeight - 8, 3, 5);

            // Wheels
            const wheelY = vanY + vanHeight - 3;
            drawWheel(vanX + vanWidth * 0.15, wheelY);
            drawWheel(vanX + vanWidth * 0.8, wheelY);

            // Headlights (horror mode)
            drawHeadlights(vanX, vanY, vanWidth, vanHeight, facingRight);
        }

        // Draw Pickup Truck
        function drawPickup(x, y, width, color, facingRight) {
            const truckWidth = width - 4;
            const truckHeight = GRID_SIZE - 10;
            const truckX = facingRight ? x + 2 : x - 2;
            const truckY = y + 5;
            const depth = 8;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.fillRect(truckX - 2, truckY + truckHeight + 2, truckWidth + 4, 3);

            // Bed section
            const bedWidth = truckWidth * 0.5;
            const cabWidth = truckWidth * 0.5;
            const bedX = facingRight ? truckX : truckX + cabWidth;
            const cabX = facingRight ? truckX + bedWidth : truckX;

            // Truck bed - lower than cab
            ctx.fillStyle = shadeColor(color, -20);
            ctx.fillRect(bedX, truckY + depth + 3, bedWidth, truckHeight - depth - 3);

            // Bed walls
            ctx.strokeStyle = shadeColor(color, -30);
            ctx.lineWidth = 2;
            ctx.strokeRect(bedX + 2, truckY + depth + 3, bedWidth - 4, truckHeight - depth - 5);

            // Cab top
            ctx.fillStyle = shadeColor(color, 15);
            ctx.fillRect(cabX + cabWidth * 0.2, truckY, cabWidth * 0.6, depth);

            // Cab body
            ctx.fillStyle = color;
            ctx.fillRect(cabX, truckY + depth, cabWidth, truckHeight - depth);

            // Windshield
            const windX = facingRight ? cabX + cabWidth * 0.45 : cabX + cabWidth * 0.25;
            const windWidth = cabWidth * 0.3;
            ctx.fillStyle = 'rgba(100, 180, 220, 0.7)';
            ctx.fillRect(windX, truckY + depth + 2, windWidth, truckHeight * 0.4);

            // Grille
            const grillX = facingRight ? cabX + cabWidth * 0.85 : cabX;
            ctx.fillStyle = '#333333';
            ctx.fillRect(grillX, truckY + depth + 2, cabWidth * 0.15, truckHeight * 0.35);

            // Lights
            const lightX = facingRight ? cabX + cabWidth - 3 : cabX + 2;
            ctx.fillStyle = facingRight ? '#FFFFCC' : '#FF3333';
            ctx.fillRect(lightX, truckY + truckHeight - 7, 3, 5);

            // Wheels
            const wheelY = truckY + truckHeight - 3;
            drawWheel(truckX + truckWidth * 0.15, wheelY);
            drawWheel(truckX + truckWidth * 0.8, wheelY);

            // Headlights (horror mode)
            drawHeadlights(truckX, truckY, truckWidth, truckHeight, facingRight);
        }

        // Draw Delivery Truck
        function drawDeliveryTruck(x, y, width, color, facingRight) {
            const truckWidth = width - 4;
            const truckHeight = GRID_SIZE - 6;
            const truckX = facingRight ? x + 2 : x - 2;
            const truckY = y + 3;
            const depth = 11;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(truckX - 3, truckY + truckHeight + 2, truckWidth + 6, 4);

            // Cargo box dimensions
            const cabWidth = truckWidth * 0.3;
            const cargoWidth = truckWidth * 0.7;
            const cabX = facingRight ? truckX + cargoWidth : truckX;
            const cargoX = facingRight ? truckX : truckX + cabWidth;

            // Cargo box - top
            ctx.fillStyle = shadeColor(color, 20);
            ctx.fillRect(cargoX + 5, truckY, cargoWidth - 10, depth);

            // Cargo box - front
            ctx.fillStyle = color;
            ctx.fillRect(cargoX, truckY + depth, cargoWidth, truckHeight - depth);

            // Cargo box details (panels)
            ctx.strokeStyle = shadeColor(color, -25);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cargoX + cargoWidth * 0.5, truckY + depth + 2);
            ctx.lineTo(cargoX + cargoWidth * 0.5, truckY + truckHeight - 2);
            ctx.stroke();

            // Cab - top
            ctx.fillStyle = shadeColor(color, 10);
            ctx.fillRect(cabX + cabWidth * 0.15, truckY + 2, cabWidth * 0.7, depth - 2);

            // Cab - front
            ctx.fillStyle = shadeColor(color, -5);
            ctx.fillRect(cabX, truckY + depth, cabWidth, truckHeight - depth);

            // Windshield
            const windX = facingRight ? cabX + cabWidth * 0.5 : cabX + cabWidth * 0.2;
            const windWidth = cabWidth * 0.3;
            ctx.fillStyle = 'rgba(100, 180, 220, 0.7)';
            ctx.fillRect(windX, truckY + depth + 2, windWidth, truckHeight * 0.4);

            // Grille
            const grillX = facingRight ? cabX + cabWidth * 0.85 : cabX;
            ctx.fillStyle = '#222222';
            ctx.fillRect(grillX, truckY + depth + 3, cabWidth * 0.15, truckHeight * 0.35);

            // Lights
            const lightX = facingRight ? cabX + cabWidth - 4 : cabX + 2;
            ctx.fillStyle = facingRight ? '#FFFFCC' : '#FF3333';
            ctx.fillRect(lightX, truckY + truckHeight - 10, 4, 6);

            // Wheels
            const wheelY = truckY + truckHeight - 4;
            drawWheel(truckX + truckWidth * 0.12, wheelY);
            drawWheel(truckX + truckWidth * 0.45, wheelY);
            drawWheel(truckX + truckWidth * 0.85, wheelY);

            // Headlights (horror mode)
            drawHeadlights(truckX, truckY, truckWidth, truckHeight, facingRight);
        }

        // Draw Semi Truck
        function drawSemiTruck(x, y, width, color, facingRight) {
            const truckWidth = width - 4;
            const truckHeight = GRID_SIZE - 5;
            const truckX = facingRight ? x + 2 : x - 2;
            const truckY = y + 2;
            const depth = 12;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
            ctx.fillRect(truckX - 4, truckY + truckHeight + 2, truckWidth + 8, 4);

            // Trailer dimensions
            const cabWidth = truckWidth * 0.28;
            const trailerWidth = truckWidth * 0.72;
            const cabX = facingRight ? truckX + trailerWidth : truckX;
            const trailerX = facingRight ? truckX : truckX + cabWidth;

            // Trailer - top
            ctx.fillStyle = shadeColor(color, 25);
            ctx.fillRect(trailerX + 6, truckY, trailerWidth - 12, depth);

            // Trailer - body
            ctx.fillStyle = color;
            ctx.fillRect(trailerX, truckY + depth, trailerWidth, truckHeight - depth);

            // Trailer details
            ctx.strokeStyle = shadeColor(color, -30);
            ctx.lineWidth = 2;
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(trailerX + trailerWidth * i, truckY + depth + 3);
                ctx.lineTo(trailerX + trailerWidth * i, truckY + truckHeight - 3);
                ctx.stroke();
            }

            // Cab - tall and boxy
            ctx.fillStyle = shadeColor(color, 15);
            ctx.fillRect(cabX + cabWidth * 0.1, truckY, cabWidth * 0.8, depth);

            // Cab body
            ctx.fillStyle = shadeColor(color, -8);
            ctx.fillRect(cabX, truckY + depth, cabWidth, truckHeight - depth);

            // Windshield
            const windX = facingRight ? cabX + cabWidth * 0.55 : cabX + cabWidth * 0.15;
            const windWidth = cabWidth * 0.3;
            ctx.fillStyle = 'rgba(100, 180, 220, 0.75)';
            ctx.fillRect(windX, truckY + depth + 3, windWidth, truckHeight * 0.45);

            // Grille
            const grillX = facingRight ? cabX + cabWidth * 0.88 : cabX;
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(grillX, truckY + depth + 5, cabWidth * 0.12, truckHeight * 0.4);

            // Exhaust pipe
            ctx.fillStyle = '#555555';
            const exhaustX = facingRight ? cabX + cabWidth * 0.15 : cabX + cabWidth * 0.85;
            ctx.fillRect(exhaustX, truckY + depth + 2, 3, truckHeight * 0.3);

            // Lights
            const lightX = facingRight ? cabX + cabWidth - 3 : cabX + 2;
            ctx.fillStyle = facingRight ? '#FFFFCC' : '#FF3333';
            ctx.fillRect(lightX, truckY + truckHeight - 12, 4, 7);

            // Wheels - many of them
            const wheelY = truckY + truckHeight - 4;
            drawWheel(truckX + truckWidth * 0.08, wheelY);
            drawWheel(truckX + truckWidth * 0.15, wheelY);
            drawWheel(truckX + truckWidth * 0.48, wheelY);
            drawWheel(truckX + truckWidth * 0.55, wheelY);
            drawWheel(truckX + truckWidth * 0.88, wheelY);

            // Headlights (horror mode)
            drawHeadlights(truckX, truckY, truckWidth, truckHeight, facingRight);
        }

        // Helper: Draw wheel with 3D effect
        function drawWheel(x, y) {
            // Wheel shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 1, y + 1, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tire
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();

            // Hubcap
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();

            // Shine
            ctx.fillStyle = '#a0a0a0';
            ctx.beginPath();
            ctx.arc(x - 1, y - 1, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Helper: Draw headlights (only at night in horror mode)
        function drawHeadlights(x, y, width, height, facingRight) {
            if (!gameSettings.horrorMode) return;
            if (timeOfDayTransition < 0.3) return; // Only visible at night

            const opacity = timeOfDayTransition * 0.8; // Fade in with night

            // Headlight positions
            const headlightY = y + height * 0.5;
            const headlightX = facingRight ? x + width - 6 : x + 6;

            // Headlight beams (gradient)
            const beamLength = 100 * opacity;
            const beamGradient = ctx.createLinearGradient(
                headlightX,
                headlightY,
                facingRight ? headlightX + beamLength : headlightX - beamLength,
                headlightY
            );
            beamGradient.addColorStop(0, `rgba(255, 255, 200, ${0.4 * opacity})`);
            beamGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

            ctx.fillStyle = beamGradient;
            ctx.fillRect(
                facingRight ? headlightX : headlightX - beamLength,
                headlightY - 15,
                beamLength,
                30
            );

            // Headlight bulbs (bright spots)
            const bulbGradient = ctx.createRadialGradient(headlightX, headlightY, 0, headlightX, headlightY, 5);
            bulbGradient.addColorStop(0, `rgba(255, 255, 220, ${opacity})`);
            bulbGradient.addColorStop(1, `rgba(255, 255, 220, ${opacity * 0.3})`);
            ctx.fillStyle = bulbGradient;
            ctx.beginPath();
            ctx.arc(headlightX, headlightY, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Helper: Shade color for 3D effect
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Main character drawing function
        function drawCharacter(x, y, flying = false) {
            switch(selectedCharacter) {
                case 'chick':
                    drawChick(x, y, flying);
                    break;
                case 'goose':
                    drawGoose(x, y, flying);
                    break;
                case 'ghost':
                    drawGhost(x, y, flying);
                    break;
                case 'military':
                    drawMilitary(x, y, flying);
                    break;
                case 'dog':
                    drawDog(x, y, flying);
                    break;
            }
        }

        // Draw an adorable golden chick
        function drawChick(x, y, flying = false) {
            const size = GRID_SIZE / 2 - 2;

            // Shadow (larger and more distant when flying)
            if (flying) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 28, size * 1.3, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 2, size * 0.9, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Fluffy body (golden yellow with gradient)
            const bodyGradient = ctx.createRadialGradient(x - 4, y - 3, 3, x, y, size);
            bodyGradient.addColorStop(0, '#FFE67C');
            bodyGradient.addColorStop(0.5, '#FFD700');
            bodyGradient.addColorStop(1, '#F4C430');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.9, 0, Math.PI * 2);
            ctx.fill();

            // Fluffy texture (small circles around body)
            ctx.fillStyle = 'rgba(255, 235, 124, 0.6)';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const fluffX = x + Math.cos(angle) * size * 0.7;
                const fluffY = y + Math.sin(angle) * size * 0.7;
                ctx.beginPath();
                ctx.arc(fluffX, fluffY, size * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }

            // Wings (tiny and cute, spread when flying)
            if (flying) {
                // Left wing (spread)
                const leftWingGradient = ctx.createRadialGradient(x - size * 0.7, y - size * 0.1, 2, x - size * 0.6, y, size * 0.4);
                leftWingGradient.addColorStop(0, '#FFE67C');
                leftWingGradient.addColorStop(1, '#F4C430');
                ctx.fillStyle = leftWingGradient;
                ctx.beginPath();
                ctx.ellipse(x - size * 0.7, y - size * 0.1, size * 0.5, size * 0.35, -0.5, 0, Math.PI * 2);
                ctx.fill();

                // Right wing (spread)
                const rightWingGradient = ctx.createRadialGradient(x + size * 0.7, y - size * 0.1, 2, x + size * 0.6, y, size * 0.4);
                rightWingGradient.addColorStop(0, '#FFE67C');
                rightWingGradient.addColorStop(1, '#F4C430');
                ctx.fillStyle = rightWingGradient;
                ctx.beginPath();
                ctx.ellipse(x + size * 0.7, y - size * 0.1, size * 0.5, size * 0.35, 0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Wing folded (small bump on side)
                ctx.fillStyle = '#F4C430';
                ctx.beginPath();
                ctx.ellipse(x + size * 0.3, y, size * 0.35, size * 0.5, 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Big cute head (slightly bigger than body for chick proportions)
            const headGradient = ctx.createRadialGradient(x, y - size * 0.9, 3, x, y - size * 0.8, size * 0.65);
            headGradient.addColorStop(0, '#FFE67C');
            headGradient.addColorStop(0.5, '#FFD700');
            headGradient.addColorStop(1, '#F4C430');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(x, y - size * 0.8, size * 0.65, 0, Math.PI * 2);
            ctx.fill();

            // Fluffy head texture
            ctx.fillStyle = 'rgba(255, 235, 124, 0.5)';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                const fluffX = x + Math.cos(angle) * size * 0.5;
                const fluffY = y - size * 0.8 + Math.sin(angle) * size * 0.5;
                ctx.beginPath();
                ctx.arc(fluffX, fluffY, size * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Small beak (orange, very small and cute)
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.4, y - size * 0.8);
            ctx.lineTo(x + size * 0.65, y - size * 0.75);
            ctx.lineTo(x + size * 0.4, y - size * 0.7);
            ctx.closePath();
            ctx.fill();

            // Big cute eyes (larger for chick look)
            // Left eye white
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y - size * 0.9, size * 0.18, 0, Math.PI * 2);
            ctx.fill();
            // Right eye white
            ctx.beginPath();
            ctx.arc(x + size * 0.15, y - size * 0.9, size * 0.18, 0, Math.PI * 2);
            ctx.fill();

            // Left eye pupil (big and shiny)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x - size * 0.12, y - size * 0.88, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Right eye pupil
            ctx.beginPath();
            ctx.arc(x + size * 0.18, y - size * 0.88, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlights (sparkle)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - size * 0.1, y - size * 0.92, size * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.2, y - size * 0.92, size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            // Running animation for chick legs
            const chickRunCycle = (Date.now() / 120) % (Math.PI * 2); // Fast waddle
            const chickLegSwing = Math.sin(chickRunCycle) * 0.2;

            // Tiny legs (orange, thin and cute) with running motion
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';

            // Left leg
            ctx.beginPath();
            ctx.moveTo(x - size * 0.25, y + size * 0.7);
            ctx.lineTo(x - size * 0.25 - chickLegSwing * size * 0.15, y + size * 1.0 + Math.abs(chickLegSwing) * size * 0.08);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(x + size * 0.25, y + size * 0.7);
            ctx.lineTo(x + size * 0.25 + chickLegSwing * size * 0.15, y + size * 1.0 + Math.abs(chickLegSwing) * size * 0.08);
            ctx.stroke();

            // Tiny feet with running motion
            ctx.lineWidth = 2;

            // Left foot toes
            const leftFootX = x - size * 0.25 - chickLegSwing * size * 0.15;
            const leftFootY = y + size * 1.0 + Math.abs(chickLegSwing) * size * 0.08;
            ctx.beginPath();
            ctx.moveTo(leftFootX, leftFootY);
            ctx.lineTo(leftFootX - size * 0.15, leftFootY + size * 0.05);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(leftFootX, leftFootY);
            ctx.lineTo(leftFootX + size * 0.1, leftFootY + size * 0.05);
            ctx.stroke();

            // Right foot toes
            const rightFootX = x + size * 0.25 + chickLegSwing * size * 0.15;
            const rightFootY = y + size * 1.0 + Math.abs(chickLegSwing) * size * 0.08;
            ctx.beginPath();
            ctx.moveTo(rightFootX, rightFootY);
            ctx.lineTo(rightFootX - size * 0.1, rightFootY + size * 0.05);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(rightFootX, rightFootY);
            ctx.lineTo(rightFootX + size * 0.15, rightFootY + size * 0.05);
            ctx.stroke();

            // Cute cheek blush (optional)
            ctx.fillStyle = 'rgba(255, 182, 193, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.4, y - size * 0.65, size * 0.15, size * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + size * 0.4, y - size * 0.65, size * 0.15, size * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a white goose
        function drawGoose(x, y, flying = false) {
            const size = GRID_SIZE / 2 - 2;

            // Shadow
            if (flying) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 30, size * 1.4, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 2, size * 1.1, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Body (white with gradient)
            const bodyGradient = ctx.createRadialGradient(x - 4, y, 3, x, y + 2, size);
            bodyGradient.addColorStop(0, '#FFFFFF');
            bodyGradient.addColorStop(0.7, '#F0F0F0');
            bodyGradient.addColorStop(1, '#E0E0E0');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(x, y + 2, size * 0.9, size * 1.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail feathers (back, fluffy)
            ctx.fillStyle = '#E8E8E8';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.9, y, size * 0.4, size * 0.6, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            if (flying) {
                // Spread wings
                ctx.fillStyle = '#F5F5F5';
                ctx.beginPath();
                ctx.ellipse(x - size * 0.8, y - size * 0.2, size * 0.7, size * 0.4, -0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(x + size * 0.8, y - size * 0.2, size * 0.7, size * 0.4, 0.6, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Folded wing
                ctx.fillStyle = '#E8E8E8';
                ctx.beginPath();
                ctx.ellipse(x + size * 0.2, y, size * 0.5, size * 0.7, 0.2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Long neck
            ctx.fillStyle = '#F8F8F8';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.3, y - size * 0.6, size * 0.25, size * 0.7, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Head
            const headGradient = ctx.createRadialGradient(x + size * 0.4, y - size * 1.1, 2, x + size * 0.4, y - size * 1.0, size * 0.45);
            headGradient.addColorStop(0, '#FFFFFF');
            headGradient.addColorStop(1, '#F0F0F0');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(x + size * 0.4, y - size * 1.0, size * 0.45, 0, Math.PI * 2);
            ctx.fill();

            // Orange beak
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.7, y - size * 1.0);
            ctx.lineTo(x + size * 1.1, y - size * 0.95);
            ctx.lineTo(x + size * 0.7, y - size * 0.9);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + size * 0.5, y - size * 1.05, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Running animation for goose legs (waddling motion)
            const gooseRunCycle = (Date.now() / 140) % (Math.PI * 2);
            const gooseLegSwing = Math.sin(gooseRunCycle) * 0.22;

            // Legs (orange) with waddle
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            // Left leg
            ctx.beginPath();
            ctx.moveTo(x - size * 0.2, y + size * 0.9);
            ctx.lineTo(x - size * 0.2 - gooseLegSwing * size * 0.18, y + size * 1.2 + Math.abs(gooseLegSwing) * size * 0.1);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(x + size * 0.2, y + size * 0.9);
            ctx.lineTo(x + size * 0.2 + gooseLegSwing * size * 0.18, y + size * 1.2 + Math.abs(gooseLegSwing) * size * 0.1);
            ctx.stroke();

            // Webbed feet with running motion
            ctx.fillStyle = '#FF8C00';

            // Left foot
            const leftFootX = x - size * 0.2 - gooseLegSwing * size * 0.18;
            const leftFootY = y + size * 1.2 + Math.abs(gooseLegSwing) * size * 0.1;
            ctx.beginPath();
            ctx.moveTo(leftFootX, leftFootY);
            ctx.lineTo(leftFootX - size * 0.2, leftFootY + size * 0.05);
            ctx.lineTo(leftFootX, leftFootY + size * 0.1);
            ctx.lineTo(leftFootX + size * 0.2, leftFootY + size * 0.05);
            ctx.closePath();
            ctx.fill();

            // Right foot
            const rightFootX = x + size * 0.2 + gooseLegSwing * size * 0.18;
            const rightFootY = y + size * 1.2 + Math.abs(gooseLegSwing) * size * 0.1;
            ctx.beginPath();
            ctx.moveTo(rightFootX, rightFootY);
            ctx.lineTo(rightFootX - size * 0.2, rightFootY + size * 0.05);
            ctx.lineTo(rightFootX, rightFootY + size * 0.1);
            ctx.lineTo(rightFootX + size * 0.2, rightFootY + size * 0.05);
            ctx.closePath();
            ctx.fill();
        }

        // Draw a spooky ghost
        function drawGhost(x, y, flying = false) {
            const size = GRID_SIZE / 2 - 2;

            // Floating effect (ghosts always float) with sway motion
            const floatCycle = Date.now() / 300;
            const floatOffset = Math.sin(floatCycle) * 5;
            const swayOffset = Math.sin(floatCycle * 1.3) * 3; // Horizontal sway for movement effect
            y -= floatOffset;
            x += swayOffset;

            // Shadow (subtle for ghost)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, y + size + 5, size * 0.6, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ghost body (semi-transparent white)
            ctx.globalAlpha = 0.85;
            const ghostGradient = ctx.createRadialGradient(x, y - size * 0.5, 5, x, y, size);
            ghostGradient.addColorStop(0, '#FFFFFF');
            ghostGradient.addColorStop(0.7, '#F0F8FF');
            ghostGradient.addColorStop(1, '#E0E8F0');
            ctx.fillStyle = ghostGradient;
            ctx.beginPath();
            ctx.arc(x, y - size * 0.3, size * 0.9, 0, Math.PI * 2);
            ctx.fill();

            // Wavy bottom
            ctx.beginPath();
            ctx.moveTo(x - size * 0.9, y);
            for (let i = 0; i <= 6; i++) {
                const waveX = x - size * 0.9 + (i * size * 0.3);
                const waveY = y + size * 0.4 + (i % 2 === 0 ? size * 0.3 : 0);
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(x + size * 0.9, y - size * 0.3);
            ctx.arc(x, y - size * 0.3, size * 0.9, 0, Math.PI);
            ctx.closePath();
            ctx.fill();

            // Eyes (black oval)
            ctx.globalAlpha = 1;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.3, y - size * 0.4, size * 0.15, size * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + size * 0.3, y - size * 0.4, size * 0.15, size * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (O shape)
            ctx.beginPath();
            ctx.arc(x, y - size * 0.1, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
        }

        // Draw a realistic military soldier
        function drawMilitary(x, y, flying = false) {
            const size = GRID_SIZE / 2 - 2;

            // If knocked down, draw soldier lying on ground
            if (militaryKnockedDown) {
                // Progress through knockdown animation (0 = just hit, 1 = getting back up)
                const knockdownProgress = militaryKnockdownTimer / 1500;

                // Shadow (bigger when knocked down)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(x, y + size * 0.5, size * 1.2, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Rotation effect - falls down and gets back up
                const rotation = knockdownProgress < 0.7 ? Math.PI / 2 : (1 - (knockdownProgress - 0.7) / 0.3) * Math.PI / 2;
                const yOffset = knockdownProgress < 0.7 ? size * 0.3 : size * 0.3 * (1 - (knockdownProgress - 0.7) / 0.3);

                ctx.save();
                ctx.translate(x, y + yOffset);
                ctx.rotate(rotation);

                // Draw simplified knocked down soldier (use camo colors)
                ctx.fillStyle = '#5C5843';
                ctx.fillRect(-size * 0.5, -size * 0.2, size, size * 1.3);

                ctx.strokeStyle = '#5C5843';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-size * 0.5, 0);
                ctx.lineTo(-size * 0.8, size * 0.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(size * 0.5, 0);
                ctx.lineTo(size * 0.8, size * 0.5);
                ctx.stroke();

                ctx.fillStyle = '#C29B7A';
                ctx.beginPath();
                ctx.arc(0, -size * 0.6, size * 0.55, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#5C5843';
                ctx.beginPath();
                ctx.ellipse(0, -size * 0.9, size * 0.65, size * 0.4, 0, 0, Math.PI);
                ctx.fill();

                if (knockdownProgress < 0.5) {
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, -size * 0.6);
                    ctx.lineTo(-size * 0.1, -size * 0.6);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, -size * 0.6);
                    ctx.lineTo(size * 0.3, -size * 0.6);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, -size * 0.6, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.2, -size * 0.6, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#3D2817';
                    ctx.beginPath();
                    ctx.arc(-size * 0.18, -size * 0.6, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.22, -size * 0.6, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.strokeStyle = '#5C5843';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(-size * 0.2, size * 0.9);
                ctx.lineTo(-size * 0.2, size * 1.3);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(size * 0.2, size * 0.9);
                ctx.lineTo(size * 0.2, size * 1.3);
                ctx.stroke();

                ctx.fillStyle = '#2C2416';
                ctx.fillRect(-size * 0.35, size * 1.2, size * 0.3, size * 0.2);
                ctx.fillRect(size * 0.05, size * 1.2, size * 0.3, size * 0.2);

                ctx.restore();
                return;
            }

            // Normal standing soldier - REALISTIC VERSION
            // Shadow
            if (flying) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 30, size * 1.0, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 2, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Neck
            ctx.fillStyle = '#B8916D';
            ctx.fillRect(x - size * 0.2, y - size * 0.25, size * 0.4, size * 0.35);

            // Torso - Camouflage uniform jacket (base tan)
            const torsoGradient = ctx.createLinearGradient(x - size * 0.6, y, x + size * 0.6, y);
            torsoGradient.addColorStop(0, '#6B6650');
            torsoGradient.addColorStop(0.5, '#5C5843');
            torsoGradient.addColorStop(1, '#6B6650');
            ctx.fillStyle = torsoGradient;
            ctx.fillRect(x - size * 0.6, y - size * 0.1, size * 1.2, size * 1.1);

            // Camouflage pattern on torso (darker spots)
            ctx.fillStyle = '#4A4731';
            ctx.beginPath();
            ctx.arc(x - size * 0.3, y + size * 0.2, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.35, y + size * 0.5, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.1, y + size * 0.7, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Camouflage pattern (lighter tan spots)
            ctx.fillStyle = '#736B52';
            ctx.beginPath();
            ctx.arc(x + size * 0.2, y + size * 0.1, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - size * 0.4, y + size * 0.6, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // Body armor/vest detail (darker rectangular shape)
            ctx.fillStyle = 'rgba(50, 50, 45, 0.5)';
            ctx.fillRect(x - size * 0.45, y + size * 0.1, size * 0.9, size * 0.7);

            // Chest pockets
            ctx.strokeStyle = '#3D3A2F';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(x - size * 0.35, y + size * 0.3, size * 0.3, size * 0.25);
            ctx.strokeRect(x + size * 0.05, y + size * 0.3, size * 0.3, size * 0.25);

            // Running animation - arms and legs swing
            const runCycle = (Date.now() / 150) % (Math.PI * 2); // Running animation speed
            const armSwing = Math.sin(runCycle) * 0.3; // Arm swing angle
            const legSwing = Math.sin(runCycle) * 0.25; // Leg swing angle

            // Left arm (swings opposite to right leg)
            ctx.strokeStyle = '#5C5843';
            ctx.lineWidth = 9;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.6, y + size * 0.1);
            ctx.lineTo(x - size * 0.85 + armSwing * size * 0.3, y + size * 0.7 - Math.abs(armSwing) * size * 0.2);
            ctx.stroke();

            // Right arm (swings opposite to left leg)
            ctx.beginPath();
            ctx.moveTo(x + size * 0.6, y + size * 0.1);
            ctx.lineTo(x + size * 0.85 - armSwing * size * 0.3, y + size * 0.7 - Math.abs(armSwing) * size * 0.2);
            ctx.stroke();

            // Left hand (skin tone)
            ctx.fillStyle = '#C29B7A';
            ctx.beginPath();
            ctx.arc(x - size * 0.85 + armSwing * size * 0.3, y + size * 0.7 - Math.abs(armSwing) * size * 0.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Right hand
            ctx.beginPath();
            ctx.arc(x + size * 0.85 - armSwing * size * 0.3, y + size * 0.7 - Math.abs(armSwing) * size * 0.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Left leg with running motion
            ctx.strokeStyle = '#5C5843';
            ctx.lineWidth = 11;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.25, y + size * 1.0);
            ctx.lineTo(x - size * 0.25 - legSwing * size * 0.15, y + size * 1.5 + Math.abs(legSwing) * size * 0.1);
            ctx.stroke();

            // Right leg with running motion
            ctx.beginPath();
            ctx.moveTo(x + size * 0.25, y + size * 1.0);
            ctx.lineTo(x + size * 0.25 + legSwing * size * 0.15, y + size * 1.5 + Math.abs(legSwing) * size * 0.1);
            ctx.stroke();

            // Left knee pad
            ctx.fillStyle = '#3D3A2F';
            ctx.beginPath();
            ctx.arc(x - size * 0.25 - legSwing * size * 0.08, y + size * 1.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Right knee pad
            ctx.beginPath();
            ctx.arc(x + size * 0.25 + legSwing * size * 0.08, y + size * 1.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Left boot (tan/brown)
            ctx.fillStyle = '#6B5230';
            ctx.save();
            ctx.translate(x - size * 0.28 - legSwing * size * 0.15, y + size * 1.57 + Math.abs(legSwing) * size * 0.1);
            ctx.rotate(legSwing * 0.15);
            ctx.fillRect(-size * 0.11, 0, size * 0.22, size * 0.25);
            ctx.restore();

            // Right boot
            ctx.save();
            ctx.translate(x + size * 0.22 + legSwing * size * 0.15, y + size * 1.57 + Math.abs(legSwing) * size * 0.1);
            ctx.rotate(-legSwing * 0.15);
            ctx.fillRect(-size * 0.11, 0, size * 0.22, size * 0.25);
            ctx.restore();

            // Left boot sole (dark)
            ctx.fillStyle = '#2C2416';
            ctx.save();
            ctx.translate(x - size * 0.28 - legSwing * size * 0.15, y + size * 1.7 + Math.abs(legSwing) * size * 0.1);
            ctx.rotate(legSwing * 0.15);
            ctx.fillRect(-size * 0.11, 0, size * 0.22, size * 0.05);
            ctx.restore();

            // Right boot sole
            ctx.save();
            ctx.translate(x + size * 0.22 + legSwing * size * 0.15, y + size * 1.7 + Math.abs(legSwing) * size * 0.1);
            ctx.rotate(-legSwing * 0.15);
            ctx.fillRect(-size * 0.11, 0, size * 0.22, size * 0.05);
            ctx.restore();

            // Head (realistic skin tone)
            ctx.fillStyle = '#C29B7A';
            ctx.beginPath();
            ctx.arc(x, y - size * 0.5, size * 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Ear
            ctx.fillStyle = '#B8916D';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.45, y - size * 0.45, size * 0.12, size * 0.18, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Military helmet with camo pattern
            ctx.fillStyle = '#5C5843';
            ctx.beginPath();
            ctx.ellipse(x, y - size * 0.8, size * 0.62, size * 0.45, 0, 0, Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x, y - size * 0.35, size * 0.65, size * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Helmet camo spots
            ctx.fillStyle = '#4A4731';
            ctx.beginPath();
            ctx.arc(x - size * 0.35, y - size * 0.7, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.3, y - size * 0.65, size * 0.18, 0, Math.PI * 2);
            ctx.fill();

            // Helmet rim/brim
            ctx.fillStyle = '#3D3A2F';
            ctx.fillRect(x - size * 0.65, y - size * 0.38, size * 1.3, size * 0.12);

            // Chin strap
            ctx.strokeStyle = '#4A4731';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y - size * 0.1, size * 0.45, 0.4, Math.PI - 0.4);
            ctx.stroke();

            // Eyebrows
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.35, y - size * 0.6);
            ctx.lineTo(x - size * 0.15, y - size * 0.62);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + size * 0.15, y - size * 0.62);
            ctx.lineTo(x + size * 0.35, y - size * 0.6);
            ctx.stroke();

            // Eyes (alert and focused)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.22, y - size * 0.5, size * 0.13, size * 0.11, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + size * 0.22, y - size * 0.5, size * 0.13, size * 0.11, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils (brown)
            ctx.fillStyle = '#3D2817';
            ctx.beginPath();
            ctx.arc(x - size * 0.22, y - size * 0.5, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.22, y - size * 0.5, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(x - size * 0.19, y - size * 0.53, size * 0.03, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.25, y - size * 0.53, size * 0.03, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.strokeStyle = '#A88160';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y - size * 0.4);
            ctx.lineTo(x - size * 0.06, y - size * 0.25);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x - size * 0.08, y - size * 0.23, size * 0.04, 0, Math.PI * 2);
            ctx.stroke();

            // Mouth (serious/neutral)
            ctx.strokeStyle = '#8B6B54';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.15, y - size * 0.15);
            ctx.lineTo(x + size * 0.15, y - size * 0.15);
            ctx.stroke();
        }

        // Draw a spotted dog
        function drawDog(x, y, flying = false) {
            // Smaller dog - reduce size by 30%
            const size = (GRID_SIZE / 2 - 2) * 0.7;

            // Shadow
            if (flying) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 20, size * 1.0, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(x, y + size + 2, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Body (white base with realistic shading)
            const bodyGradient = ctx.createRadialGradient(x - size * 0.2, y - size * 0.1, 2, x, y, size * 0.8);
            bodyGradient.addColorStop(0, '#FFFFFF');
            bodyGradient.addColorStop(0.7, '#F5F5F5');
            bodyGradient.addColorStop(1, '#E8E8E8');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.85, size * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // More gray spots than black on body
            // Gray spots (5 spots)
            ctx.fillStyle = '#888888';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(x - size * 0.5, y - size * 0.15, size * 0.22, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.25, y + size * 0.15, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y + size * 0.25, size * 0.18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.45, y - size * 0.05, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - size * 0.35, y + size * 0.35, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Black spots (2 spots - fewer than gray)
            ctx.fillStyle = '#2C2C2C';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(x + size * 0.05, y - size * 0.25, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - size * 0.25, y + size * 0.05, size * 0.16, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Head (white with gradient shading)
            const headGradient = ctx.createRadialGradient(x + size * 0.2, y - size * 0.75, 2, x + size * 0.3, y - size * 0.7, size * 0.5);
            headGradient.addColorStop(0, '#FFFFFF');
            headGradient.addColorStop(0.8, '#F5F5F5');
            headGradient.addColorStop(1, '#E0E0E0');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(x + size * 0.3, y - size * 0.7, size * 0.55, 0, Math.PI * 2);
            ctx.fill();

            // Gray spots on head (more realistic placement)
            ctx.fillStyle = '#888888';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(x + size * 0.15, y - size * 0.85, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.45, y - size * 0.75, size * 0.22, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Long floppy ears (down to mouth level) - more realistic
            // Left ear - gray with darker tip
            ctx.fillStyle = '#999999';
            ctx.beginPath();
            ctx.ellipse(x, y - size * 0.55, size * 0.23, size * 0.48, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#777777';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.05, y - size * 0.25, size * 0.18, size * 0.25, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Right ear - lighter gray
            ctx.fillStyle = '#AAAAAA';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.6, y - size * 0.55, size * 0.23, size * 0.48, 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#888888';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.65, y - size * 0.25, size * 0.18, size * 0.25, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Snout with realistic shading
            const snoutGradient = ctx.createRadialGradient(x + size * 0.5, y - size * 0.52, 2, x + size * 0.5, y - size * 0.48, size * 0.28);
            snoutGradient.addColorStop(0, '#F0F0F0');
            snoutGradient.addColorStop(0.6, '#E5E5E5');
            snoutGradient.addColorStop(1, '#D5D5D5');
            ctx.fillStyle = snoutGradient;
            ctx.beginPath();
            ctx.ellipse(x + size * 0.5, y - size * 0.48, size * 0.28, size * 0.22, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose (shiny black with highlight)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + size * 0.6, y - size * 0.53, size * 0.13, 0, Math.PI * 2);
            ctx.fill();
            // Nose highlight for realism
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(x + size * 0.57, y - size * 0.56, size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            // Eyes with more realistic details
            // Eye whites
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + size * 0.2, y - size * 0.75, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.45, y - size * 0.8, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            // Eye pupils
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(x + size * 0.22, y - size * 0.73, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.47, y - size * 0.78, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            // Eye highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x + size * 0.24, y - size * 0.76, size * 0.03, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.49, y - size * 0.81, size * 0.03, 0, Math.PI * 2);
            ctx.fill();

            // Running animation for dog legs (galloping motion)
            const dogRunCycle = (Date.now() / 100) % (Math.PI * 2); // Fast running
            const frontLegSwing = Math.sin(dogRunCycle) * 0.25;
            const backLegSwing = Math.sin(dogRunCycle + Math.PI) * 0.25; // Back legs opposite to front

            // Legs (white with subtle shading) with running motion
            ctx.strokeStyle = '#F0F0F0';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';

            // Front left leg
            ctx.beginPath();
            ctx.moveTo(x - size * 0.35, y + size * 0.55);
            ctx.lineTo(x - size * 0.35 - frontLegSwing * size * 0.15, y + size * 0.95 + Math.abs(frontLegSwing) * size * 0.1);
            ctx.stroke();

            // Front right leg (opposite phase)
            ctx.beginPath();
            ctx.moveTo(x - size * 0.05, y + size * 0.55);
            ctx.lineTo(x - size * 0.05 + frontLegSwing * size * 0.15, y + size * 0.95 + Math.abs(frontLegSwing) * size * 0.1);
            ctx.stroke();

            // Back left leg (opposite to front legs)
            ctx.beginPath();
            ctx.moveTo(x + size * 0.25, y + size * 0.55);
            ctx.lineTo(x + size * 0.25 - backLegSwing * size * 0.15, y + size * 0.95 + Math.abs(backLegSwing) * size * 0.1);
            ctx.stroke();

            // Back right leg
            ctx.beginPath();
            ctx.moveTo(x + size * 0.5, y + size * 0.55);
            ctx.lineTo(x + size * 0.5 + backLegSwing * size * 0.15, y + size * 0.95 + Math.abs(backLegSwing) * size * 0.1);
            ctx.stroke();

            // Paws (dark gray, realistic) with running motion
            ctx.fillStyle = '#555555';

            // Front left paw
            ctx.beginPath();
            ctx.ellipse(x - size * 0.35 - frontLegSwing * size * 0.15, y + size * 0.95 + Math.abs(frontLegSwing) * size * 0.1, size * 0.12, size * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Front right paw
            ctx.beginPath();
            ctx.ellipse(x - size * 0.05 + frontLegSwing * size * 0.15, y + size * 0.95 + Math.abs(frontLegSwing) * size * 0.1, size * 0.12, size * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Back left paw
            ctx.beginPath();
            ctx.ellipse(x + size * 0.25 - backLegSwing * size * 0.15, y + size * 0.95 + Math.abs(backLegSwing) * size * 0.1, size * 0.12, size * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Back right paw
            ctx.beginPath();
            ctx.ellipse(x + size * 0.5 + backLegSwing * size * 0.15, y + size * 0.95 + Math.abs(backLegSwing) * size * 0.1, size * 0.12, size * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wagging tail (curved and fluffy)
            const tailWag = Math.sin(Date.now() / 100) * 0.35;
            ctx.strokeStyle = '#F0F0F0';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.75, y);
            ctx.bezierCurveTo(
                x - size * 0.85, y - size * 0.25 + tailWag,
                x - size * 0.75, y - size * 0.45 + tailWag,
                x - size * 0.65, y - size * 0.55
            );
            ctx.stroke();

            // Tail tip (darker gray)
            ctx.fillStyle = '#AAAAAA';
            ctx.beginPath();
            ctx.arc(x - size * 0.65, y - size * 0.55, size * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a scary grey wolf/dog
        function drawWolf(x, y) {
            const size = GRID_SIZE / 2 - 2;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + size + 2, size * 1.2, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body (dark grey)
            const bodyGradient = ctx.createRadialGradient(x - 3, y, 2, x, y + 2, size);
            bodyGradient.addColorStop(0, '#5a5a5a');
            bodyGradient.addColorStop(0.6, '#3a3a3a');
            bodyGradient.addColorStop(1, '#2a2a2a');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(x, y + 4, size * 1.1, size * 1.0, 0, 0, Math.PI * 2);
            ctx.fill();

            // Back fur ridge (spiky)
            ctx.fillStyle = '#4a4a4a';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(x - size * 0.6 + i * size * 0.3, y);
                ctx.lineTo(x - size * 0.5 + i * size * 0.3, y - size * 0.3);
                ctx.lineTo(x - size * 0.4 + i * size * 0.3, y);
                ctx.closePath();
                ctx.fill();
            }

            // Tail (bushy)
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.9, y + size * 0.2);
            ctx.quadraticCurveTo(x - size * 1.5, y - size * 0.3, x - size * 1.3, y + size * 0.5);
            ctx.quadraticCurveTo(x - size * 1.4, y + size * 0.2, x - size * 0.9, y + size * 0.4);
            ctx.closePath();
            ctx.fill();

            // Head (menacing)
            const headGradient = ctx.createRadialGradient(x + size * 0.4, y - size * 0.5, 2, x + size * 0.5, y - size * 0.4, size * 0.6);
            headGradient.addColorStop(0, '#5a5a5a');
            headGradient.addColorStop(0.7, '#3a3a3a');
            headGradient.addColorStop(1, '#2a2a2a');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.ellipse(x + size * 0.5, y - size * 0.4, size * 0.6, size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#4a4a4a';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.9, y - size * 0.3, size * 0.35, size * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose (black)
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x + size * 1.1, y - size * 0.35, size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Ears (pointed)
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.3, y - size * 0.7);
            ctx.lineTo(x + size * 0.2, y - size * 1.1);
            ctx.lineTo(x + size * 0.4, y - size * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + size * 0.6, y - size * 0.7);
            ctx.lineTo(x + size * 0.65, y - size * 1.15);
            ctx.lineTo(x + size * 0.7, y - size * 0.8);
            ctx.closePath();
            ctx.fill();

            // Eyes (red glowing)
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(x + size * 0.55, y - size * 0.5, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.75, y - size * 0.5, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Eye pupils (black)
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x + size * 0.57, y - size * 0.5, size * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.77, y - size * 0.5, size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (snarling)
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + size * 0.8, y - size * 0.2);
            ctx.quadraticCurveTo(x + size * 0.9, y - size * 0.1, x + size * 1.0, y - size * 0.15);
            ctx.stroke();

            // Teeth (sharp and scary)
            ctx.fillStyle = '#ffffff';
            // Upper teeth
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(x + size * (0.85 + i * 0.08), y - size * 0.15);
                ctx.lineTo(x + size * (0.83 + i * 0.08), y - size * 0.05);
                ctx.lineTo(x + size * (0.87 + i * 0.08), y - size * 0.15);
                ctx.closePath();
                ctx.fill();
            }
            // Lower teeth
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x + size * (0.88 + i * 0.08), y - size * 0.05);
                ctx.lineTo(x + size * (0.86 + i * 0.08), y + size * 0.02);
                ctx.lineTo(x + size * (0.90 + i * 0.08), y - size * 0.05);
                ctx.closePath();
                ctx.fill();
            }

            // Legs (muscular)
            ctx.fillStyle = '#3a3a3a';
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 3;
            // Front legs
            ctx.beginPath();
            ctx.moveTo(x + size * 0.3, y + size * 0.8);
            ctx.lineTo(x + size * 0.3, y + size * 1.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + size * 0.6, y + size * 0.8);
            ctx.lineTo(x + size * 0.6, y + size * 1.2);
            ctx.stroke();
            // Back legs
            ctx.beginPath();
            ctx.moveTo(x - size * 0.2, y + size * 0.8);
            ctx.lineTo(x - size * 0.2, y + size * 1.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y + size * 0.8);
            ctx.lineTo(x - size * 0.5, y + size * 1.2);
            ctx.stroke();

            // Claws
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for (let leg of [x + size * 0.3, x + size * 0.6, x - size * 0.2, x - size * 0.5]) {
                ctx.beginPath();
                ctx.moveTo(leg - 3, y + size * 1.2);
                ctx.lineTo(leg - 5, y + size * 1.3);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(leg + 3, y + size * 1.2);
                ctx.lineTo(leg + 5, y + size * 1.3);
                ctx.stroke();
            }
        }

        // Draw sun/moon in top right corner
        function drawSunMoon() {
            const x = canvas.width - 60;
            const y = 60;
            const radius = 35;

            if (!gameSettings.horrorMode) {
                // Always draw sun if horror mode is off
                drawSunOnly(x, y, radius, 1);
            } else {
                // Draw sun or moon based on time of day transition
                const sunOpacity = 1 - timeOfDayTransition;
                const moonOpacity = timeOfDayTransition;

                if (sunOpacity > 0) {
                    drawSunOnly(x, y, radius, sunOpacity);
                }
                if (moonOpacity > 0) {
                    drawMoonOnly(x, y, radius, moonOpacity);
                }
            }
        }

        function drawSunOnly(sunX, sunY, sunRadius, opacity) {
            ctx.globalAlpha = opacity;

            // Sun glow
            const glowGradient = ctx.createRadialGradient(sunX, sunY, sunRadius * 0.5, sunX, sunY, sunRadius * 1.5);
            glowGradient.addColorStop(0, `rgba(255, 255, 0, ${0.3 * opacity})`);
            glowGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Sun body
            const sunGradient = ctx.createRadialGradient(sunX - 10, sunY - 10, 5, sunX, sunY, sunRadius);
            sunGradient.addColorStop(0, '#FFFF99');
            sunGradient.addColorStop(0.5, '#FFD700');
            sunGradient.addColorStop(1, '#FFA500');
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();

            // Sun rays
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                const x1 = sunX + Math.cos(angle) * (sunRadius + 5);
                const y1 = sunY + Math.sin(angle) * (sunRadius + 5);
                const x2 = sunX + Math.cos(angle) * (sunRadius + 15);
                const y2 = sunY + Math.sin(angle) * (sunRadius + 15);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
        }

        function drawMoonOnly(moonX, moonY, moonRadius, opacity) {
            ctx.globalAlpha = opacity;

            // Moon glow
            const glowGradient = ctx.createRadialGradient(moonX, moonY, moonRadius * 0.5, moonX, moonY, moonRadius * 1.5);
            glowGradient.addColorStop(0, `rgba(200, 220, 255, ${0.3 * opacity})`);
            glowGradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Moon body
            const moonGradient = ctx.createRadialGradient(moonX - 10, moonY - 10, 5, moonX, moonY, moonRadius);
            moonGradient.addColorStop(0, '#F0F0F0');
            moonGradient.addColorStop(0.5, '#E0E0E0');
            moonGradient.addColorStop(1, '#C0C0C0');
            ctx.fillStyle = moonGradient;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
            ctx.fill();

            // Moon craters
            ctx.fillStyle = 'rgba(160, 160, 160, 0.4)';
            ctx.beginPath();
            ctx.arc(moonX - 8, moonY - 5, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moonX + 10, moonY + 8, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moonX + 5, moonY - 12, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
        }

        // Draw coin with 3D effect
        function drawShopBuilding(x, y) {
            const buildingWidth = GRID_SIZE * 3;
            const buildingHeight = GRID_SIZE * 2.5;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(x - buildingWidth / 2 + 5, y + buildingHeight + 5, buildingWidth, 10);

            // Building base
            const buildingGradient = ctx.createLinearGradient(x - buildingWidth / 2, y, x + buildingWidth / 2, y);
            buildingGradient.addColorStop(0, '#8B4513');
            buildingGradient.addColorStop(0.5, '#A0522D');
            buildingGradient.addColorStop(1, '#8B4513');
            ctx.fillStyle = buildingGradient;
            ctx.fillRect(x - buildingWidth / 2, y, buildingWidth, buildingHeight);

            // Building outline
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.strokeRect(x - buildingWidth / 2, y, buildingWidth, buildingHeight);

            // Roof
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.moveTo(x - buildingWidth / 2 - 10, y);
            ctx.lineTo(x, y - 30);
            ctx.lineTo(x + buildingWidth / 2 + 10, y);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#660000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Door
            ctx.fillStyle = '#654321';
            ctx.fillRect(x - 20, y + buildingHeight - 50, 40, 50);
            ctx.strokeStyle = '#4A3319';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 20, y + buildingHeight - 50, 40, 50);

            // Door handle
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x + 10, y + buildingHeight - 25, 3, 0, Math.PI * 2);
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x - 50, y + 30, 25, 25);
            ctx.fillRect(x + 25, y + 30, 25, 25);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 50, y + 30, 25, 25);
            ctx.strokeRect(x + 25, y + 30, 25, 25);

            // Window crosses
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 37.5, y + 30);
            ctx.lineTo(x - 37.5, y + 55);
            ctx.moveTo(x - 50, y + 42.5);
            ctx.lineTo(x - 25, y + 42.5);
            ctx.moveTo(x + 37.5, y + 30);
            ctx.lineTo(x + 37.5, y + 55);
            ctx.moveTo(x + 25, y + 42.5);
            ctx.lineTo(x + 50, y + 42.5);
            ctx.stroke();

            // Sign above door
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 40, y + buildingHeight - 70, 80, 15);
            ctx.strokeStyle = '#D4A017';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 40, y + buildingHeight - 70, 80, 15);

            // "SHOP" text
            ctx.fillStyle = '#8B0000';
            ctx.font = 'bold 14px Poppins';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('SHOP', x, y + buildingHeight - 62.5);

            // Entry indicator (pulsing)
            const pulseAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3;
            ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha})`;
            ctx.font = 'bold 14px Poppins';
            ctx.fillText('WALK HERE TO ENTER', x, y + buildingHeight + 25);

            // Arrow pointing to building
            ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha})`;
            ctx.font = 'bold 20px Poppins';
            ctx.fillText('↓', x, y + buildingHeight + 10);
        }

        function drawCoin(x, y) {
            const coinRadius = 12;

            // Coin shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + 2, coinRadius * 0.8, coinRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Outer ring (darker gold)
            ctx.fillStyle = '#D4A017';
            ctx.beginPath();
            ctx.arc(x, y, coinRadius, 0, Math.PI * 2);
            ctx.fill();

            // Inner coin (bright gold)
            const coinGradient = ctx.createRadialGradient(x - 3, y - 3, 2, x, y, coinRadius - 2);
            coinGradient.addColorStop(0, '#FFD700');
            coinGradient.addColorStop(0.5, '#FFC700');
            coinGradient.addColorStop(1, '#D4A017');
            ctx.fillStyle = coinGradient;
            ctx.beginPath();
            ctx.arc(x, y, coinRadius - 2, 0, Math.PI * 2);
            ctx.fill();

            // Coin highlight (shine effect)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - 4, y - 4, coinRadius * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Center symbol (optional $ or circle)
            ctx.strokeStyle = '#D4A017';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, coinRadius * 0.4, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Horror Mode: Spawn monsters at night
        function spawnNightMonsters() {
            monsters = [];

            // Spawn bats (3-5 bats)
            const numBats = Math.floor(Math.random() * 3) + 3;
            for (let i = 0; i < numBats; i++) {
                monsters.push({
                    type: 'bat',
                    x: Math.random() * COLS,
                    worldY: player.worldY - 5 - Math.random() * 5, // Spawn ahead of player
                    waveOffset: Math.random() * Math.PI * 2, // Random starting position in W wave
                    waveAmplitude: 2, // Height of the W wave
                    speed: 0.03 + Math.random() * 0.02, // Horizontal speed
                    direction: Math.random() > 0.5 ? 1 : -1 // Left or right
                });
            }

            // Spawn zombies (2-3 zombies)
            const numZombies = Math.floor(Math.random() * 2) + 2;
            for (let i = 0; i < numZombies; i++) {
                monsters.push({
                    type: 'zombie',
                    x: Math.floor(Math.random() * COLS),
                    worldY: player.worldY - 10 - Math.random() * 5, // Spawn ahead of player
                    speed: 0.015 + Math.random() * 0.01, // Downward speed (slower than bats)
                    wobbleOffset: Math.random() * Math.PI * 2 // For side-to-side wobble
                });
            }
        }

        // Horror Mode: Update monsters
        function updateMonsters(deltaTime) {
            const normalizedDelta = deltaTime / 16.67; // Normalize to 60 FPS

            monsters.forEach(monster => {
                if (monster.type === 'bat') {
                    // Move horizontally
                    monster.x += monster.speed * monster.direction * normalizedDelta;

                    // Wrap around screen edges
                    if (monster.x < -1) monster.x = COLS;
                    if (monster.x > COLS + 1) monster.x = -1;

                    // Update wave offset for W-shaped movement
                    monster.waveOffset += 0.1 * normalizedDelta;
                } else if (monster.type === 'zombie') {
                    // Move downward
                    monster.worldY += monster.speed * normalizedDelta;

                    // Update wobble for side-to-side movement
                    monster.wobbleOffset += 0.05 * normalizedDelta;
                }
            });

            // Remove monsters that are far behind the player
            monsters = monsters.filter(monster => monster.worldY < player.worldY + 10);

            // Check monster collisions
            checkMonsterCollision();
        }

        // Horror Mode: Draw monsters
        function drawMonsters() {
            monsters.forEach(monster => {
                const screenY = (monster.worldY - cameraY) * GRID_SIZE;
                if (screenY < -GRID_SIZE || screenY > canvas.height) return;

                if (monster.type === 'bat') {
                    // Calculate W-shaped vertical offset
                    const waveY = Math.sin(monster.waveOffset) * monster.waveAmplitude * GRID_SIZE;
                    drawBat(monster.x * GRID_SIZE, screenY + waveY);
                } else if (monster.type === 'zombie') {
                    // Calculate side-to-side wobble
                    const wobbleX = Math.sin(monster.wobbleOffset) * 0.2 * GRID_SIZE;
                    drawZombie(monster.x * GRID_SIZE + wobbleX, screenY);
                }
            });
        }

        // Draw bat monster
        function drawBat(x, y) {
            const size = 20;

            // Bat body (small circle)
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Bat wings (animated flap using sine wave)
            const flapAngle = Math.sin(Date.now() / 100) * 0.3;

            ctx.fillStyle = '#1a1a1a';
            // Left wing
            ctx.beginPath();
            ctx.ellipse(x - size * 0.4, y, size * 0.6, size * 0.3, flapAngle, 0, Math.PI * 2);
            ctx.fill();
            // Right wing
            ctx.beginPath();
            ctx.ellipse(x + size * 0.4, y, size * 0.6, size * 0.3, -flapAngle, 0, Math.PI * 2);
            ctx.fill();

            // Red eyes
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 3, y - 2, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw zombie monster
        function drawZombie(x, y) {
            const size = GRID_SIZE * 0.8;

            // Zombie body (rectangle)
            ctx.fillStyle = '#4a7c59';
            ctx.fillRect(x - size / 4, y, size / 2, size * 0.7);

            // Zombie head
            ctx.fillStyle = '#6b9776';
            ctx.beginPath();
            ctx.arc(x, y - size * 0.1, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // Torn clothes (darker patches)
            ctx.fillStyle = '#3a6c49';
            ctx.fillRect(x - size / 5, y + size * 0.2, size / 2.5, size * 0.15);

            // Arms
            ctx.strokeStyle = '#6b9776';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x - size / 4, y + size * 0.2);
            ctx.lineTo(x - size / 2, y + size * 0.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + size / 4, y + size * 0.2);
            ctx.lineTo(x + size / 2, y + size * 0.4);
            ctx.stroke();

            // Red eyes
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(x - 6, y - size * 0.1 - 3, 4, 4);
            ctx.fillRect(x + 2, y - size * 0.1 - 3, 4, 4);
        }

        // Check monster collision
        function checkMonsterCollision() {
            if (isFlying || inShop) return; // No collision when flying or in shop

            monsters.forEach(monster => {
                const dx = monster.x - player.x;
                const dy = monster.worldY - player.worldY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 0.7) { // Close enough to hit
                    endGame();
                }
            });
        }

        // Check collision
        function checkCollision() {
            // Don't check collision when flying, ghost phasing, military is knocked down, or in shop
            if (isFlying || ghostPhasing || militaryKnockedDown || inShop) return;

            // Check if player is on Rainbow Road - no collisions on Rainbow Road
            const playerOnRainbowRoad = rainbowRoadActive &&
                                       player.worldY <= rainbowRoadStartY &&
                                       player.worldY >= rainbowRoadEndY;
            if (playerOnRainbowRoad) return;

            cars.forEach(car => {
                if (Math.floor(car.y) === player.worldY) {
                    const carLeft = car.x;
                    const carRight = car.x + car.width;
                    const playerPos = player.x + 0.5;

                    if (playerPos >= carLeft && playerPos <= carRight) {
                        // Military character has 2 lives - knock down and get back up
                        if (selectedCharacter === 'military' && militaryLives > 1) {
                            militaryLives--;
                            militaryKnockedDown = true;
                            militaryKnockdownTimer = 0; // Reset timer for knockdown animation (1.5 seconds)
                            updatePowerDisplay();
                        } else {
                            endGame();
                        }
                    }
                }
            });
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            // ESC key to exit shop
            if (e.key === 'Escape' && inShop) {
                exitShop();
                return;
            }

            if (gameOver) return;

            // Space bar for character powers
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();

                // Goose honk - stops all cars for 5 seconds
                if (selectedCharacter === 'goose' && gooseHonksRemaining > 0) {
                    gooseHonksRemaining--;
                    carsStoppedUntil = Date.now() + 5000; // Stop cars for 5 seconds
                    updatePowerDisplay();
                }

                // Ghost phasing - phase through cars for 3 seconds
                if (selectedCharacter === 'ghost' && !ghostPhasing) {
                    ghostPhasing = true;
                    ghostPhasingUntil = Date.now() + 3000; // Phase for 3 seconds
                    updatePowerDisplay();
                }

                return;
            }

            // R key for Rainbow Road activation
            if ((e.key === 'r' || e.key === 'R') && powerUpRainbowOwned && !rainbowRoadActive && gameStarted && !inShop) {
                e.preventDefault();
                // Activate Rainbow Road - spawn it ahead of player
                rainbowRoadActive = true;
                rainbowRoadStartY = player.worldY - 5; // 5 rows ahead of player
                rainbowRoadEndY = rainbowRoadStartY - 20; // Lasts for 20 spaces
                rainbowRoadColumn = player.x; // Same column as player

                // Remove all cars that are on the Rainbow Road
                cars = cars.filter(car => {
                    const carY = Math.floor(car.y);
                    const isOnRainbowRoad = carY <= rainbowRoadStartY && carY >= rainbowRoadEndY;
                    return !isOnRainbowRoad; // Keep cars that are NOT on rainbow road
                });

                // Mark as used - player needs to buy again
                powerUpRainbowOwned = false;
                const rainbowShopItem = document.querySelector('[data-powerup="rainbow"]');
                if (rainbowShopItem) {
                    rainbowShopItem.classList.remove('purchased');
                    rainbowShopItem.querySelector('.shop-card-status').textContent = 'Click to Purchase';
                }
                return;
            }

            // T key for Tsunami activation
            if ((e.key === 't' || e.key === 'T') && powerUpTsunamiOwned && !tsunamiActive && gameStarted && !inShop) {
                e.preventDefault();
                // Activate Tsunami
                tsunamiActive = true;
                tsunamiEndTime = Date.now() + 6000; // 6 seconds
                // Randomly choose direction: left-to-right or right-to-left
                tsunamiDirection = Math.random() > 0.5 ? 1 : -1;
                tsunamiX = tsunamiDirection === 1 ? -2 : COLS + 2;

                // Mark as used - player needs to buy again
                powerUpTsunamiOwned = false;
                const tsunamiShopItem = document.querySelector('[data-powerup="tsunami"]');
                if (tsunamiShopItem) {
                    tsunamiShopItem.classList.remove('purchased');
                    tsunamiShopItem.querySelector('.shop-card-status').textContent = 'Click to Purchase';
                }
                return;
            }

            // Check flight movement delay
            if (isFlying && Date.now() - lastMoveTime < gameSettings.flightMovementDelay) {
                e.preventDefault();
                return; // Prevent movement if too soon during flight
            }

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    handleMove('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    handleMove('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    handleMove('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    handleMove('right');
                    break;
            }
        });

        // Mobile touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const swipeThreshold = 30; // Minimum distance for a swipe
        const tapThreshold = 200; // Maximum time for a tap (ms)

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameOver) return;

            const touch = e.changedTouches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            const touchDuration = Date.now() - touchStartTime;

            // Check flight movement delay
            if (isFlying && Date.now() - lastMoveTime < gameSettings.flightMovementDelay) {
                return;
            }

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            // Check if it's a tap (quick touch with minimal movement)
            if (touchDuration < tapThreshold && absDeltaX < swipeThreshold && absDeltaY < swipeThreshold) {
                // Tap = move forward (up)
                handleMove('up');
            }
            // Check if it's a swipe
            else if (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold) {
                // Determine primary swipe direction
                if (absDeltaX > absDeltaY) {
                    // Horizontal swipe
                    if (deltaX > 0) {
                        handleMove('right');
                    } else {
                        handleMove('left');
                    }
                } else {
                    // Vertical swipe
                    if (deltaY > 0) {
                        handleMove('down');
                    } else {
                        handleMove('up');
                    }
                }
            }
        }, { passive: false });

        // Unified movement handler for both keyboard and touch
        function handleMove(direction) {
            if (gameOver) return;

            // Check flight movement delay
            if (isFlying && Date.now() - lastMoveTime < gameSettings.flightMovementDelay) {
                return;
            }

            switch(direction) {
                case 'up':
                    player.worldY--;
                    player.isHopping = true;
                    player.hopProgress = 0;
                    if (isFlying) lastMoveTime = Date.now();

                    // Update max progress
                    if (player.worldY < maxWorldY) {
                        maxWorldY = player.worldY;
                        score++;

                        // Reset wolf timer when making forward progress
                        timeSinceLastForwardMove = 0;

                        // Check if it's time to spawn a coin
                        if (score === nextCoinSpawn) {
                            const distanceRange = gameSettings.coinSpawnDistanceMax - gameSettings.coinSpawnDistanceMin;
                            coinObjects.push({
                                x: Math.floor(Math.random() * COLS),
                                y: player.worldY - Math.floor(Math.random() * distanceRange + gameSettings.coinSpawnDistanceMin),
                                collected: false
                            });
                            const spawnRange = gameSettings.coinSpawnMax - gameSettings.coinSpawnMin;
                            nextCoinSpawn = score + Math.floor(Math.random() * spawnRange) + gameSettings.coinSpawnMin;
                        }

                        // Check for win condition
                        if (score >= gameSettings.winScore) {
                            winGame();
                        }
                    }
                    updateScoreDisplay();
                    break;

                case 'down':
                    // Don't allow moving past the starting position
                    if (player.worldY < startingWorldY) {
                        player.worldY++;
                        player.isHopping = true;
                        player.hopProgress = 0;
                        if (isFlying) lastMoveTime = Date.now();
                        updateScoreDisplay();
                    }
                    break;

                case 'left':
                    if (player.x > 0) {
                        player.x--;
                        player.isHopping = true;
                        player.hopProgress = 0;
                        if (isFlying) lastMoveTime = Date.now();
                    }
                    break;

                case 'right':
                    if (player.x < COLS - 1) {
                        player.x++;
                        player.isHopping = true;
                        player.hopProgress = 0;
                        if (isFlying) lastMoveTime = Date.now();
                    }
                    break;
            }
        }

        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('coinDisplay').textContent = coins;
        }

        function updatePowerDisplay() {
            const powerDisplay = document.getElementById('powerDisplay');

            // Emma (Dog) - always show speed boost indicator
            if (selectedCharacter === 'dog') {
                powerDisplay.innerHTML = '🐕 Emma - Speed Boost: +0.8%';
                powerDisplay.classList.remove('active');
            }
            // Goose - show honk availability
            else if (selectedCharacter === 'goose') {
                const carsStopped = Date.now() < carsStoppedUntil;
                if (carsStopped) {
                    const timeRemaining = ((carsStoppedUntil - Date.now()) / 1000).toFixed(1);
                    powerDisplay.innerHTML = '🦆 HONK ACTIVE: ' + timeRemaining + 's';
                    powerDisplay.classList.add('active');
                } else if (gooseHonksRemaining > 0) {
                    powerDisplay.innerHTML = '🦆 Press SPACE to Honk (stops cars)';
                    powerDisplay.classList.remove('active');
                } else {
                    powerDisplay.innerHTML = '🦆 Honk Used';
                    powerDisplay.classList.remove('active');
                }
            }
            // Military - show lives
            else if (selectedCharacter === 'military') {
                powerDisplay.innerHTML = '🪖 Lives: ' + '❤️'.repeat(militaryLives);
                powerDisplay.classList.remove('active');
            }
            // Ghost - show phasing status
            else if (selectedCharacter === 'ghost') {
                if (ghostPhasing) {
                    const timeRemaining = ((ghostPhasingUntil - Date.now()) / 1000).toFixed(1);
                    powerDisplay.innerHTML = '👻 PHASING: ' + timeRemaining + 's';
                    powerDisplay.classList.add('active');
                } else {
                    powerDisplay.innerHTML = '👻 Press SPACE to Phase (3s)';
                    powerDisplay.classList.remove('active');
                }
            }
            // Chick - no special power
            else if (selectedCharacter === 'chick') {
                powerDisplay.innerHTML = '🐥 No special power';
                powerDisplay.classList.remove('active');
            }
        }

        function endGame() {
            // Check if player has extra lives from power-up
            if (powerUpExtraLives > 0) {
                powerUpExtraLives--;
                // Reset player position to safe location
                player.worldY = player.worldY + 2; // Move back 2 rows
                player.renderWorldY = player.worldY;
                return; // Don't end game, continue playing
            }

            gameOver = true;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('crossyRoadHighScore', highScore);
            }

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalHighScore').textContent = highScore;
            document.getElementById('gameOver').style.display = 'block';
        }

        function winGame() {
            gameOver = true;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('crossyRoadHighScore', highScore);
            }

            document.getElementById('gameOver').querySelector('h2').textContent = 'YOU WIN!';
            document.getElementById('gameOver').querySelector('h2').style.color = '#4ECDC4';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalHighScore').textContent = highScore;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            gameOver = false;
            score = 0;
            coins = 0;
            coinObjects = [];
            const spawnRange = gameSettings.coinSpawnMax - gameSettings.coinSpawnMin;
            nextCoinSpawn = Math.floor(Math.random() * spawnRange) + gameSettings.coinSpawnMin;
            isFlying = false;
            flightTimeRemaining = 0;
            lastMoveTime = 0;
            wolfWorldY = ROWS - 1;
            wolfX = Math.floor(COLS / 2);
            wolfRenderX = Math.floor(COLS / 2);
            timeSinceLastForwardMove = 0;
            wolfChasing = false;
            gameStarted = false;
            document.getElementById('settingsBtn').classList.remove('hidden');
            document.getElementById('flightDisplay').classList.remove('active');
            player.x = Math.floor(COLS / 2);
            player.y = ROWS - 2;
            player.worldY = ROWS - 2;
            player.renderX = Math.floor(COLS / 2);
            player.renderWorldY = ROWS - 2;
            player.isHopping = false;
            player.hopProgress = 0;
            player.hopHeight = 0;
            cars = [];
            roads = [];
            cameraY = ROWS - 2 - (ROWS - 5);
            minRowGenerated = 0;
            startingWorldY = ROWS - 2;
            maxWorldY = ROWS - 2;

            // Reset character powers
            gooseHonksRemaining = 1;
            carsStoppedUntil = 0;
            militaryLives = 2;
            militaryKnockedDown = false;
            militaryKnockdownTimer = 0;
            ghostPhasing = false;
            ghostPhasingUntil = 0;

            // Reset game over message
            document.getElementById('gameOver').querySelector('h2').textContent = 'GAME OVER!';
            document.getElementById('gameOver').querySelector('h2').style.color = '#ff6b6b';
            document.getElementById('gameOver').style.display = 'none';

            init();
            updateScoreDisplay();
            updatePowerDisplay();
        }

        // Game loop with delta time for smooth 60fps
        let lastTime = performance.now();
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            update(deltaTime);
            draw();
            updatePowerDisplay(); // Update power display every frame
            requestAnimationFrame(gameLoop);
        }

        // Fullscreen functionality
        let isFullscreen = false;

        function toggleFullscreen() {
            if (isFullscreen) {
                exitFullscreen();
            } else {
                enterFullscreen();
            }
        }

        function enterFullscreen() {
            const fullscreenContainer = document.getElementById('fullscreenContainer');
            const exitBtn = document.getElementById('exitFullscreenBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const gameOverScreen = document.getElementById('gameOver');

            // Move entire canvas container and game over screen to fullscreen
            fullscreenContainer.appendChild(canvasContainer);
            fullscreenContainer.appendChild(gameOverScreen);
            fullscreenContainer.classList.add('active');
            exitBtn.classList.add('show');
            fullscreenBtn.textContent = '✕ Exit Fullscreen';
            isFullscreen = true;

            // Request browser fullscreen
            const elem = fullscreenContainer;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { // IE11
                elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {            
            const fullscreenContainer = document.getElementById('fullscreenContainer');
            const exitBtn = document.getElementById('exitFullscreenBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const gameContainer = document.querySelector('.game-container');
            const gameOverScreen = document.getElementById('gameOver');

            // Exit browser fullscreen
            if (document.fullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }

            // Move canvas container back to game container
            // Insert after the score-board div
            const scoreBoard = gameContainer.querySelector('.score-board');
            scoreBoard.parentNode.insertBefore(canvasContainer, scoreBoard.nextSibling);

            // Move game over screen back to body
            document.body.appendChild(gameOverScreen);

            fullscreenContainer.classList.remove('active');
            exitBtn.classList.remove('show');
            fullscreenBtn.textContent = '⛶ Fullscreen';
            isFullscreen = false;
        }

        // Listen for ESC key to exit fullscreen
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                exitFullscreen();
            }
        });

        document.addEventListener('webkitfullscreenchange', () => {
            if (!document.webkitFullscreenElement) {
                exitFullscreen();
            }
        });

        // Settings Modal Functions
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            loadSettingsToModal();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function loadSettingsToModal() {
            document.getElementById('vehicleDensityMin').value = gameSettings.vehicleDensityMin;
            document.getElementById('vehicleDensityMax').value = gameSettings.vehicleDensityMax;
            document.getElementById('vehicleSpeedMin').value = gameSettings.vehicleSpeedMin;
            document.getElementById('vehicleSpeedMax').value = gameSettings.vehicleSpeedMax;
            document.getElementById('vehicleSpawnFrequency').value = gameSettings.vehicleSpawnFrequency;
            document.getElementById('minLanes').value = gameSettings.minLanes;
            document.getElementById('maxLanes').value = gameSettings.maxLanes;
            document.getElementById('coinsForFlight').value = gameSettings.coinsForFlight;
            document.getElementById('flightDuration').value = gameSettings.flightDuration / 1000; // Convert to seconds
            document.getElementById('flightMovementDelay').value = gameSettings.flightMovementDelay;
            document.getElementById('coinSpawnMin').value = gameSettings.coinSpawnMin;
            document.getElementById('coinSpawnMax').value = gameSettings.coinSpawnMax;
            document.getElementById('coinSpawnDistanceMin').value = gameSettings.coinSpawnDistanceMin;
            document.getElementById('coinSpawnDistanceMax').value = gameSettings.coinSpawnDistanceMax;
            document.getElementById('wolfChaseDelay').value = gameSettings.wolfChaseDelay / 1000; // Convert to seconds
            document.getElementById('wolfSpeed').value = gameSettings.wolfSpeed;
            document.getElementById('wolfSpawnDistance').value = gameSettings.wolfSpawnDistance;
            document.getElementById('winScore').value = gameSettings.winScore;
            document.getElementById('shopUnlockScore').value = gameSettings.shopUnlockScore;
            document.getElementById('horrorMode').checked = gameSettings.horrorMode;
            document.getElementById('dayDuration').value = gameSettings.dayDuration / 1000; // Convert to seconds
            document.getElementById('nightDuration').value = gameSettings.nightDuration / 1000; // Convert to seconds
        }

        function saveSettingsFromModal() {
            gameSettings.vehicleDensityMin = parseInt(document.getElementById('vehicleDensityMin').value);
            gameSettings.vehicleDensityMax = parseInt(document.getElementById('vehicleDensityMax').value);
            gameSettings.vehicleSpeedMin = parseFloat(document.getElementById('vehicleSpeedMin').value);
            gameSettings.vehicleSpeedMax = parseFloat(document.getElementById('vehicleSpeedMax').value);
            gameSettings.vehicleSpawnFrequency = parseInt(document.getElementById('vehicleSpawnFrequency').value);
            gameSettings.minLanes = parseInt(document.getElementById('minLanes').value);
            gameSettings.maxLanes = parseInt(document.getElementById('maxLanes').value);
            gameSettings.coinsForFlight = parseInt(document.getElementById('coinsForFlight').value);
            gameSettings.flightDuration = parseFloat(document.getElementById('flightDuration').value) * 1000; // Convert to ms
            gameSettings.flightMovementDelay = parseInt(document.getElementById('flightMovementDelay').value);
            gameSettings.coinSpawnMin = parseInt(document.getElementById('coinSpawnMin').value);
            gameSettings.coinSpawnMax = parseInt(document.getElementById('coinSpawnMax').value);
            gameSettings.coinSpawnDistanceMin = parseInt(document.getElementById('coinSpawnDistanceMin').value);
            gameSettings.coinSpawnDistanceMax = parseInt(document.getElementById('coinSpawnDistanceMax').value);
            gameSettings.wolfChaseDelay = parseFloat(document.getElementById('wolfChaseDelay').value) * 1000; // Convert to ms
            gameSettings.wolfSpeed = parseFloat(document.getElementById('wolfSpeed').value);
            gameSettings.wolfSpawnDistance = parseInt(document.getElementById('wolfSpawnDistance').value);
            gameSettings.winScore = parseInt(document.getElementById('winScore').value);
            gameSettings.shopUnlockScore = parseInt(document.getElementById('shopUnlockScore').value);
            gameSettings.horrorMode = document.getElementById('horrorMode').checked;
            gameSettings.dayDuration = parseFloat(document.getElementById('dayDuration').value) * 1000; // Convert to ms
            gameSettings.nightDuration = parseFloat(document.getElementById('nightDuration').value) * 1000; // Convert to ms

            saveSettings();
            closeSettings();
            alert('Settings saved! Restart the game for changes to take effect.');
        }

        function resetSettings() {
            if (confirm('Reset all settings to default values?')) {
                gameSettings = {
                    vehicleDensityMin: 1,
                    vehicleDensityMax: 2,
                    vehicleSpeedMin: 0.02,
                    vehicleSpeedMax: 0.05,
                    vehicleSpawnFrequency: 3,
                    minLanes: 1,
                    maxLanes: 5,
                    coinsForFlight: 5,
                    flightDuration: 5000,
                    flightMovementDelay: 150,
                    coinSpawnMin: 5,
                    coinSpawnMax: 18,
                    coinSpawnDistanceMin: 8,
                    coinSpawnDistanceMax: 12,
                    winScore: 333,
                    gridSize: 50,
                    hopSpeed: 0.008,
                    hopHeight: 15,
                    cameraSmoothing: 0.15,
                    wolfChaseDelay: 3000,
                    wolfSpeed: 2,
                    wolfSpawnDistance: 5,
                    shopUnlockScore: 70,
                    horrorMode: false,
                    dayDuration: 30000,
                    nightDuration: 20000
                };
                saveSettings();
                loadSettingsToModal();
                alert('Settings reset to defaults!');
            }
        }

        // Hide settings button once game starts
        let gameStarted = false;
        const originalKeydownHandler = document.addEventListener;
        document.addEventListener('keydown', (e) => {
            if (!gameStarted && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                gameStarted = true;
                document.getElementById('settingsBtn').classList.add('hidden');
            }
        });

        // Character selection function
        function selectCharacter(character) {
            selectedCharacter = character;

            // Update active state in UI
            document.querySelectorAll('.character-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`[data-character="${character}"]`).classList.add('active');

            // Reset character powers when selecting new character
            gooseHonksRemaining = 1;
            carsStoppedUntil = 0;
            militaryLives = 2;
            militaryKnockedDown = false;
            militaryKnockdownTimer = 0;
            ghostPhasing = false;
            ghostPhasingUntil = 0;

            // Update power display immediately
            updatePowerDisplay();

            // Restart game with new character
            if (gameStarted) {
                restartGame();
            }
        }

        // Shop Functions
        let shopSafeTime = 0; // Timestamp when safe period ends after leaving shop
        let shopAirstrikeCodeInput = ''; // Code input while in shop

        function enterShop() {
            inShop = true;
            const shopElement = document.getElementById('fullscreenShop');
            if (shopElement) {
                console.log('showing shop again');
                shopElement.style.display = 'block';
            }
            document.getElementById('shopCoins').textContent = coins;
        }

        function closeShopAirstrikePanel() {
            document.getElementById('shopAirstrikePanel').style.display = 'none';
            shopAirstrikeCodeInput = '';
            document.getElementById('shopCodeInput').textContent = '';
        }

        function exitShop() {
            console.log('exitShop called'); // Debug
            inShop = false;
            const shopElement = document.getElementById('fullscreenShop');
            if (shopElement) {
                shopElement.style.display = 'none';
                console.log('Shop display set to none'); // Debug
            } else {
                console.log('Shop element not found!'); // Debug
            }

            // Move player 2 spaces forward (up) from shop
            player.worldY -= 2;
            player.renderWorldY = player.worldY;

            // Set cooldown - player can't re-enter shop for 3 seconds
            shopCooldown = Date.now() + 3000;

            // Clear all cars and enemies for 2 seconds
            cars = [];
            monsters = [];

            // Stop wolf chasing and send it far away for 9 seconds
            wolfChasing = false;
            const tempWolfY = wolfWorldY; // Save old position
            wolfWorldY = player.worldY + 999; // Send wolf far away

            // Reset wolf after 9 seconds
            setTimeout(() => {
                wolfChasing = false;
                timeSinceLastForwardMove = 0; // Reset wolf chase timer
            }, 9000);

            // Set safe time - 2 seconds from now
            shopSafeTime = Date.now() + 2000;

            // After 2 seconds, respawn cars for existing roads
            setTimeout(() => {
                respawnCarsAfterShop();
            }, 2000);
        }

        // Add event listener for close shop button
        window.addEventListener('DOMContentLoaded', function() {
            const closeBtn = document.getElementById('closeShopBtn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Close button clicked!'); // Debug
                    exitShop();
                });
                console.log('Close button listener added');
            } else {
                console.log('Close button not found!');
            }
        });

        function respawnCarsAfterShop() {
            // Regenerate cars for all existing roads
            roads.forEach(road => {
                if (road.laneCount > 1) {
                    // Multi-lane road
                    road.lanes = road.lanes || [];
                    road.lanes.length = 0; // Clear existing lanes

                    for (let i = 0; i < road.laneCount; i++) {
                        const laneDirection = (i % 2 === 0) ? 1 : -1;
                        const vehicleCount = Math.floor(Math.random() * 2) + 1;
                        const vehicles = [];

                        for (let v = 0; v < vehicleCount; v++) {
                            const vehicleType = getRandomVehicleType();
                            const vehicleX = (Math.random() * COLS * 2) - COLS;
                            vehicles.push({
                                x: vehicleX,
                                type: vehicleType.type,
                                width: vehicleType.width,
                                speed: (Math.random() * 0.03 + 0.02) * laneDirection,
                                color: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#FFD93D'][Math.floor(Math.random() * 6)]
                            });
                        }

                        road.lanes.push({
                            direction: laneDirection,
                            vehicles: vehicles
                        });
                    }

                    // Flatten vehicles for main cars array
                    road.lanes.forEach((lane, laneIndex) => {
                        lane.vehicles.forEach(vehicle => {
                            cars.push({
                                ...vehicle,
                                y: road.row + laneIndex,
                                lane: laneIndex
                            });
                        });
                    });
                }
            });

            // Respawn monsters if in horror mode
            if (gameSettings.horrorMode && isNightTime) {
                spawnNightMonsters();
            }
        }

        function buyPowerUp(powerUpType) {
            const shopItem = document.querySelector(`[data-powerup="${powerUpType}"]`);

            // Check if already purchased
            if (shopItem && shopItem.classList.contains('purchased')) {
                return;
            }

            // Power-up costs
            const costs = {
                'speed': 1,
                'freeze': 1,
                'lives': 2,
                'airstrike': 4,
                'rainbow': 4,
                'tsunami': 5
            };

            const cost = costs[powerUpType];

            // Check if player has enough coins
            if (coins < cost) {
                return; // Not enough coins
            }

            // Deduct coins
            coins -= cost;

            // Apply power-up
            switch(powerUpType) {
                case 'speed':
                    powerUpSpeedBoost = 1.009; // 0.9% speed boost
                    powerUpSpeedBoostActive = true;
                    if (shopItem) {
                        shopItem.classList.add('purchased');
                        shopItem.querySelector('.shop-card-status').textContent = 'PURCHASED';
                    }
                    break;

                case 'freeze':
                    powerUpFreezeTime = true;
                    powerUpFreezeUntil = Date.now() + 4000; // Freeze for 4 seconds
                    if (shopItem) shopItem.classList.add('purchased');
                    // Allow multiple purchases of freeze
                    setTimeout(() => {
                        if (shopItem) {
                            shopItem.classList.remove('purchased');
                            shopItem.querySelector('.shop-card-status').textContent = 'Click to Purchase';
                        }
                    }, 4000);
                    // Exit shop after purchase
                    exitShop();
                    break;

                case 'lives':
                    powerUpExtraLives += 2;
                    if (shopItem) {
                        shopItem.classList.add('purchased');
                        shopItem.querySelector('.shop-card-status').textContent = 'PURCHASED';
                    }
                    break;

                case 'airstrike':
                    // Activate airstrike immediately
                    powerUpAirstrikeOwned = true;
                    if (shopItem) {
                        shopItem.classList.add('purchased');
                        shopItem.querySelector('.shop-card-status').textContent = 'PURCHASED';
                    }
                    // Show the code panel permanently at bottom
                    document.getElementById('airstrikeCodePanel').style.display = 'flex';
                    break;

                case 'rainbow':
                    // Give player Rainbow Road power-up
                    powerUpRainbowOwned = true;
                    if (shopItem) {
                        shopItem.classList.add('purchased');
                        shopItem.querySelector('.shop-card-status').textContent = 'PURCHASED - Press R';
                    }
                    break;

                case 'tsunami':
                    // Give player Tsunami power-up
                    powerUpTsunamiOwned = true;
                    if (shopItem) {
                        shopItem.classList.add('purchased');
                        shopItem.querySelector('.shop-card-status').textContent = 'PURCHASED - Press T';
                    }
                    break;
            }

            // Update coin displays
            document.getElementById('coinDisplay').textContent = `💰 ${coins}`;
            document.getElementById('shopCoins').textContent = coins;
        }

        // Airstrike code input handler - works during gameplay (not in shop)
        document.addEventListener('keydown', function(e) {
            // Only accept input if airstrike is owned and game is running and not in shop
            if (!powerUpAirstrikeOwned || !gameStarted || gameOver || inShop || airstrikeAnimating) {
                return;
            }

            // Only accept number keys
            if (e.key >= '0' && e.key <= '9') {
                airstrikeCodeInput += e.key;

                // Show feedback in the permanent panel
                document.getElementById('airstrikeInputFeedback').textContent = airstrikeCodeInput;

                // Check if code is complete (4 digits)
                if (airstrikeCodeInput.length === 4) {
                    if (airstrikeCodeInput === '6741') {
                        // Correct code! Launch airstrike
                        launchAirstrike();
                    } else {
                        // Wrong code, show red and reset
                        const feedbackEl = document.getElementById('airstrikeInputFeedback');
                        feedbackEl.style.color = '#ff4444';
                        setTimeout(() => {
                            airstrikeCodeInput = '';
                            feedbackEl.textContent = '';
                            feedbackEl.style.color = '#4ade80';
                        }, 500);
                    }
                }
            } else if (e.key === 'Backspace' && airstrikeCodeInput.length > 0) {
                airstrikeCodeInput = airstrikeCodeInput.slice(0, -1);
                document.getElementById('airstrikeInputFeedback').textContent = airstrikeCodeInput;
            }
        });

        function launchAirstrike() {
            // Clear the input feedback
            airstrikeCodeInput = '';
            document.getElementById('airstrikeInputFeedback').textContent = '';

            // Show "AIRSTRIKE INCOMING" message
            const airstrikeMsg = document.getElementById('airstrikeMessage');
            airstrikeMsg.style.display = 'block';

            // After 1.5 seconds, start the missile animation
            setTimeout(() => {
                airstrikeMsg.style.display = 'none';
                airstrikeAnimating = true;
                airstrikeY = -50; // Start above screen
            }, 1500);
        }

        // Render character previews (face/head only)
        function renderCharacterPreviews() {
            const previewSize = 60;
            const centerX = previewSize / 2;
            const centerY = previewSize / 2;

            // Preview for each character - draw just their face
            ['chick', 'goose', 'ghost', 'military', 'dog'].forEach(character => {
                const canvas = document.getElementById(`preview-${character}`);
                if (!canvas) return;

                const previewCtx = canvas.getContext('2d');
                canvas.width = previewSize;
                canvas.height = previewSize;

                // Clear canvas
                previewCtx.clearRect(0, 0, previewSize, previewSize);

                // Draw character face
                switch(character) {
                    case 'chick':
                        drawChickFace(previewCtx, centerX, centerY);
                        break;
                    case 'goose':
                        drawGooseFace(previewCtx, centerX, centerY);
                        break;
                    case 'ghost':
                        drawGhostFace(previewCtx, centerX, centerY);
                        break;
                    case 'military':
                        drawMilitaryFace(previewCtx, centerX, centerY);
                        break;
                    case 'dog':
                        drawDogFace(previewCtx, centerX, centerY);
                        break;
                }
            });
        }

        // Draw just the chick's face for preview
        function drawChickFace(ctx, x, y) {
            const size = 20;

            // Fluffy body (golden)
            const bodyGradient = ctx.createRadialGradient(x, y, 2, x, y, size);
            bodyGradient.addColorStop(0, '#FFE67C');
            bodyGradient.addColorStop(0.6, '#FFD700');
            bodyGradient.addColorStop(1, '#F4C430');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();

            // Head (slightly brighter)
            ctx.fillStyle = '#FFE67C';
            ctx.beginPath();
            ctx.arc(x, y - size * 0.3, size * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Big sparkly eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x - size * 0.3, y - size * 0.4, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.3, y - size * 0.4, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Eye sparkles
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - size * 0.25, y - size * 0.45, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.35, y - size * 0.45, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Tiny orange beak
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.1, y - size * 0.1);
            ctx.lineTo(x + size * 0.1, y - size * 0.1);
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.fill();
        }

        // Draw just the goose's face for preview
        function drawGooseFace(ctx, x, y) {
            const size = 20;

            // Head (white)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.9, 0, Math.PI * 2);
            ctx.fill();

            // Long neck extending down
            ctx.fillStyle = '#F8F8F8';
            ctx.fillRect(x - size * 0.3, y, size * 0.6, size * 1.2);

            // Orange beak
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.8, y, size * 0.5, size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x - size * 0.2, y - size * 0.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.2, y - size * 0.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw just the ghost's face for preview
        function drawGhostFace(ctx, x, y) {
            const size = 20;

            // Ghost body (semi-transparent)
            ctx.globalAlpha = 0.85;
            const ghostGradient = ctx.createRadialGradient(x, y - size * 0.3, 3, x, y, size);
            ghostGradient.addColorStop(0, '#FFFFFF');
            ghostGradient.addColorStop(0.7, '#F0F8FF');
            ghostGradient.addColorStop(1, '#E0E8F0');
            ctx.fillStyle = ghostGradient;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (black oval)
            ctx.globalAlpha = 1;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.35, y - size * 0.2, size * 0.2, size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + size * 0.35, y - size * 0.2, size * 0.2, size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (O shape)
            ctx.beginPath();
            ctx.arc(x, y + size * 0.3, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
        }

        // Draw just the military soldier's face for preview
        function drawMilitaryFace(ctx, x, y) {
            const size = 20;

            // Head (realistic skin tone)
            ctx.fillStyle = '#C29B7A';
            ctx.beginPath();
            ctx.arc(x, y + size * 0.1, size * 0.85, 0, Math.PI * 2);
            ctx.fill();

            // Neck
            ctx.fillStyle = '#B8916D';
            ctx.fillRect(x - size * 0.25, y + size * 0.7, size * 0.5, size * 0.5);

            // Military helmet with camo pattern
            ctx.fillStyle = '#5C5843'; // Base tan/brown
            ctx.beginPath();
            ctx.ellipse(x, y - size * 0.5, size * 1.1, size * 0.7, 0, 0, Math.PI);
            ctx.fill();

            // Helmet camo spots (darker)
            ctx.fillStyle = '#4A4731';
            ctx.beginPath();
            ctx.arc(x - size * 0.5, y - size * 0.6, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.4, y - size * 0.5, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // Helmet camo spots (lighter tan)
            ctx.fillStyle = '#736B52';
            ctx.beginPath();
            ctx.arc(x - size * 0.2, y - size * 0.7, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.6, y - size * 0.6, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Helmet rim/brim
            ctx.fillStyle = '#3D3A2F';
            ctx.fillRect(x - size * 1.1, y - size * 0.3, size * 2.2, size * 0.2);

            // Helmet strap under chin
            ctx.strokeStyle = '#4A4731';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y + size * 0.5, size * 0.6, 0.3, Math.PI - 0.3);
            ctx.stroke();

            // Eyebrows (serious/focused look)
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.55, y - size * 0.05);
            ctx.lineTo(x - size * 0.25, y - size * 0.1);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + size * 0.25, y - size * 0.1);
            ctx.lineTo(x + size * 0.55, y - size * 0.05);
            ctx.stroke();

            // Eyes (alert and focused)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.35, y + size * 0.05, size * 0.18, size * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + size * 0.35, y + size * 0.05, size * 0.18, size * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils (brown/dark)
            ctx.fillStyle = '#3D2817';
            ctx.beginPath();
            ctx.arc(x - size * 0.35, y + size * 0.05, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.35, y + size * 0.05, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - size * 0.32, y + size * 0.02, size * 0.04, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.38, y + size * 0.02, size * 0.04, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.strokeStyle = '#A88160';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + size * 0.15);
            ctx.lineTo(x - size * 0.08, y + size * 0.3);
            ctx.stroke();

            // Mouth (neutral/serious expression)
            ctx.strokeStyle = '#8B6B54';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.25, y + size * 0.5);
            ctx.lineTo(x + size * 0.25, y + size * 0.5);
            ctx.stroke();

            // Uniform collar (camo pattern)
            ctx.fillStyle = '#5C5843';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.4, y + size * 0.9);
            ctx.lineTo(x - size * 0.25, y + size * 0.7);
            ctx.lineTo(x + size * 0.25, y + size * 0.7);
            ctx.lineTo(x + size * 0.4, y + size * 0.9);
            ctx.lineTo(x, y + size * 1.0);
            ctx.closePath();
            ctx.fill();
        }

        // Draw just the dog's face for preview
        function drawDogFace(ctx, x, y) {
            const size = 15;

            // Head (white with gradient)
            const headGradient = ctx.createRadialGradient(x - size * 0.2, y - size * 0.3, 2, x, y, size);
            headGradient.addColorStop(0, '#FFFFFF');
            headGradient.addColorStop(0.8, '#F5F5F5');
            headGradient.addColorStop(1, '#E0E0E0');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(x, y, size * 1.0, 0, Math.PI * 2);
            ctx.fill();

            // Gray spots on head
            ctx.fillStyle = '#888888';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(x - size * 0.4, y - size * 0.5, size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.5, y - size * 0.3, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Floppy ears
            ctx.fillStyle = '#999999';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.8, y, size * 0.4, size * 0.8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#AAAAAA';
            ctx.beginPath();
            ctx.ellipse(x + size * 0.8, y, size * 0.4, size * 0.8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            const snoutGradient = ctx.createRadialGradient(x, y + size * 0.4, 2, x, y + size * 0.4, size * 0.5);
            snoutGradient.addColorStop(0, '#F0F0F0');
            snoutGradient.addColorStop(1, '#D5D5D5');
            ctx.fillStyle = snoutGradient;
            ctx.beginPath();
            ctx.ellipse(x, y + size * 0.5, size * 0.5, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x, y + size * 0.4, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            // Nose highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(x - size * 0.05, y + size * 0.35, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Eyes with whites
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - size * 0.35, y - size * 0.2, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.35, y - size * 0.2, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(x - size * 0.3, y - size * 0.15, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.4, y - size * 0.15, size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - size * 0.25, y - size * 0.2, size * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.45, y - size * 0.2, size * 0.05, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start game
        init();

        // Render character previews after a short delay to ensure everything is loaded
        setTimeout(renderCharacterPreviews, 100);

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
